<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 14.6.1"/>
    <title>skeletor.skeletonize API documentation</title>

    <style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
    <style>/*! syntax-highlighting.css */pre{line-height:125%;}span.linenos{color:inherit; background-color:transparent; padding-left:5px; padding-right:20px;}.pdoc-code .hll{background-color:#ffffcc}.pdoc-code{background:#f8f8f8;}.pdoc-code .c{color:#3D7B7B; font-style:italic}.pdoc-code .err{border:1px solid #FF0000}.pdoc-code .k{color:#008000; font-weight:bold}.pdoc-code .o{color:#666666}.pdoc-code .ch{color:#3D7B7B; font-style:italic}.pdoc-code .cm{color:#3D7B7B; font-style:italic}.pdoc-code .cp{color:#9C6500}.pdoc-code .cpf{color:#3D7B7B; font-style:italic}.pdoc-code .c1{color:#3D7B7B; font-style:italic}.pdoc-code .cs{color:#3D7B7B; font-style:italic}.pdoc-code .gd{color:#A00000}.pdoc-code .ge{font-style:italic}.pdoc-code .gr{color:#E40000}.pdoc-code .gh{color:#000080; font-weight:bold}.pdoc-code .gi{color:#008400}.pdoc-code .go{color:#717171}.pdoc-code .gp{color:#000080; font-weight:bold}.pdoc-code .gs{font-weight:bold}.pdoc-code .gu{color:#800080; font-weight:bold}.pdoc-code .gt{color:#0044DD}.pdoc-code .kc{color:#008000; font-weight:bold}.pdoc-code .kd{color:#008000; font-weight:bold}.pdoc-code .kn{color:#008000; font-weight:bold}.pdoc-code .kp{color:#008000}.pdoc-code .kr{color:#008000; font-weight:bold}.pdoc-code .kt{color:#B00040}.pdoc-code .m{color:#666666}.pdoc-code .s{color:#BA2121}.pdoc-code .na{color:#687822}.pdoc-code .nb{color:#008000}.pdoc-code .nc{color:#0000FF; font-weight:bold}.pdoc-code .no{color:#880000}.pdoc-code .nd{color:#AA22FF}.pdoc-code .ni{color:#717171; font-weight:bold}.pdoc-code .ne{color:#CB3F38; font-weight:bold}.pdoc-code .nf{color:#0000FF}.pdoc-code .nl{color:#767600}.pdoc-code .nn{color:#0000FF; font-weight:bold}.pdoc-code .nt{color:#008000; font-weight:bold}.pdoc-code .nv{color:#19177C}.pdoc-code .ow{color:#AA22FF; font-weight:bold}.pdoc-code .w{color:#bbbbbb}.pdoc-code .mb{color:#666666}.pdoc-code .mf{color:#666666}.pdoc-code .mh{color:#666666}.pdoc-code .mi{color:#666666}.pdoc-code .mo{color:#666666}.pdoc-code .sa{color:#BA2121}.pdoc-code .sb{color:#BA2121}.pdoc-code .sc{color:#BA2121}.pdoc-code .dl{color:#BA2121}.pdoc-code .sd{color:#BA2121; font-style:italic}.pdoc-code .s2{color:#BA2121}.pdoc-code .se{color:#AA5D1F; font-weight:bold}.pdoc-code .sh{color:#BA2121}.pdoc-code .si{color:#A45A77; font-weight:bold}.pdoc-code .sx{color:#008000}.pdoc-code .sr{color:#A45A77}.pdoc-code .s1{color:#BA2121}.pdoc-code .ss{color:#19177C}.pdoc-code .bp{color:#008000}.pdoc-code .fm{color:#0000FF}.pdoc-code .vc{color:#19177C}.pdoc-code .vg{color:#19177C}.pdoc-code .vi{color:#19177C}.pdoc-code .vm{color:#19177C}.pdoc-code .il{color:#666666}</style>
    <style>/*! theme.css */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f8f8f8;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}</style>
    <style>/*! layout.css */html, body{width:100%;height:100%;}html, main{scroll-behavior:smooth;}body{background-color:var(--pdoc-background);}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;z-index:999;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}header + main{margin-top:-3rem;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}header + main{margin-top:-4rem;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;opacity:0;}nav.pdoc{--pad:clamp(0.5rem, 2vw, 1.75rem);--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent; z-index:1}nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc > div > ul{margin-left:calc(0px - var(--pad));}nav.pdoc li a{padding:.2rem 0 .2rem calc(var(--pad) + var(--indent));}nav.pdoc > div > ul > li > a{padding-left:var(--pad);}nav.pdoc li{transition:all 100ms;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}</style>
    <style>/*! content.css */.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{cursor:pointer;display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .alert{padding:1rem 1rem 1rem calc(1.5rem + 24px);border:1px solid transparent;border-radius:.25rem;background-repeat:no-repeat;background-position:.75rem center;margin-bottom:1rem;}.pdoc .alert > em{display:none;}.pdoc .alert > *:last-child{margin-bottom:0;}.pdoc .alert.note {color:#084298;background-color:#cfe2ff;border-color:#b6d4fe;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23084298%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8%2016A8%208%200%201%200%208%200a8%208%200%200%200%200%2016zm.93-9.412-1%204.705c-.07.34.029.533.304.533.194%200%20.487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703%200-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381%202.29-.287zM8%205.5a1%201%200%201%201%200-2%201%201%200%200%201%200%202z%22/%3E%3C/svg%3E");}.pdoc .alert.warning{color:#664d03;background-color:#fff3cd;border-color:#ffecb5;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23664d03%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8.982%201.566a1.13%201.13%200%200%200-1.96%200L.165%2013.233c-.457.778.091%201.767.98%201.767h13.713c.889%200%201.438-.99.98-1.767L8.982%201.566zM8%205c.535%200%20.954.462.9.995l-.35%203.507a.552.552%200%200%201-1.1%200L7.1%205.995A.905.905%200%200%201%208%205zm.002%206a1%201%200%201%201%200%202%201%201%200%200%201%200-2z%22/%3E%3C/svg%3E");}.pdoc .alert.danger{color:#842029;background-color:#f8d7da;border-color:#f5c2c7;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23842029%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M5.52.359A.5.5%200%200%201%206%200h4a.5.5%200%200%201%20.474.658L8.694%206H12.5a.5.5%200%200%201%20.395.807l-7%209a.5.5%200%200%201-.873-.454L6.823%209.5H3.5a.5.5%200%200%201-.48-.641l2.5-8.5z%22/%3E%3C/svg%3E");}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc > section:not(.module-info) h1{font-size:1.5rem;font-weight:500;}.pdoc > section:not(.module-info) h2{font-size:1.4rem;font-weight:500;}.pdoc > section:not(.module-info) h3{font-size:1.3rem;font-weight:500;}.pdoc > section:not(.module-info) h4{font-size:1.2rem;}.pdoc > section:not(.module-info) h5{font-size:1.1rem;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-top:0;margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;background-color:var(--code);}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--accent);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc > section:not(.module-info){margin-bottom:1.5rem;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.view-source-toggle-state,.view-source-toggle-state ~ .pdoc-code{display:none;}.view-source-toggle-state:checked ~ .pdoc-code{display:block;}.view-source-button{display:inline-block;float:right;font-size:.75rem;line-height:1.5rem;color:var(--muted);padding:0 .4rem 0 1.3rem;cursor:pointer;text-indent:-2px;}.view-source-button > span{visibility:hidden;}.module-info .view-source-button{float:none;display:flex;justify-content:flex-end;margin:-1.2rem .4rem -.2rem 0;}.view-source-button::before{position:absolute;content:"View Source";display:list-item;list-style-type:disclosure-closed;}.view-source-toggle-state:checked ~ .attr .view-source-button::before,.view-source-toggle-state:checked ~ .view-source-button::before{list-style-type:disclosure-open;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc section:not(.module-info) .docstring{margin-left:clamp(0rem, 5vw - 2rem, 1rem);}.pdoc .docstring .pdoc-code{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target,.pdoc .pdoc-code > pre > span:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc .pdoc-code > pre > span:target{display:block;}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc *{scroll-margin:2rem;}.pdoc .pdoc-code .linenos{user-select:none;}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc section, .pdoc .classattr{position:relative;}.pdoc .headerlink{--width:clamp(1rem, 3vw, 2rem);position:absolute;top:0;left:calc(0rem - var(--width));transition:all 100ms ease-in-out;opacity:0;}.pdoc .headerlink::before{content:"#";display:block;text-align:center;width:var(--width);height:2.3rem;line-height:2.3rem;font-size:1.5rem;}.pdoc .attr:hover ~ .headerlink,.pdoc *:target > .headerlink,.pdoc .headerlink:hover{opacity:1;}.pdoc .attr{display:block;margin:.5rem 0 .5rem;padding:.4rem .4rem .4rem 1rem;background-color:var(--accent);overflow-x:auto;}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{background-color:transparent;}.pdoc .param, .pdoc .return-annotation{white-space:pre;}.pdoc .signature.multiline .param{display:block;}.pdoc .signature.condensed .param{display:inline-block;}.pdoc .annotation{color:var(--annotation);}.pdoc .view-value-toggle-state,.pdoc .view-value-toggle-state ~ .default_value{display:none;}.pdoc .view-value-toggle-state:checked ~ .default_value{display:inherit;}.pdoc .view-value-button{font-size:.5rem;vertical-align:middle;border-style:dashed;margin-top:-0.1rem;}.pdoc .view-value-button:hover{background:white;}.pdoc .view-value-button::before{content:"show";text-align:center;width:2.2em;display:inline-block;}.pdoc .view-value-toggle-state:checked ~ .view-value-button::before{content:"hide";}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
    <style>/*! custom.css */</style></head>
<body>
    <nav class="pdoc">
        <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
        <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
        <div>            <a class="pdoc-button module-list-button" href="../skeletor.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                &nbsp;skeletor</a>


            <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                   pattern=".+" required>

            <h2>Contents</h2>
            <ul>
  <li><a href="#references">References</a></li>
</ul>



            <h2>API Documentation</h2>
                <ul class="memberlist">
            <li>
                    <a class="function" href="#by_teasar">by_teasar</a>
            </li>
            <li>
                    <a class="function" href="#by_wavefront">by_wavefront</a>
            </li>
            <li>
                    <a class="function" href="#by_vertex_clusters">by_vertex_clusters</a>
            </li>
            <li>
                    <a class="function" href="#by_edge_collapse">by_edge_collapse</a>
            </li>
            <li>
                    <a class="function" href="#by_tangent_ball">by_tangent_ball</a>
            </li>
    </ul>



        <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev" target="_blank">
            built with <span class="visually-hidden">pdoc</span><img
                alt="pdoc logo"
                src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
        </a>
</div>
    </nav>
    <main class="pdoc">
            <section class="module-info">
                    <h1 class="modulename">
<a href="./../skeletor.html">skeletor</a><wbr>.skeletonize    </h1>

                        <div class="docstring"><p>The <code><a href="">skeletor.skeletonize</a></code> module contains functions to for skeletonization
of meshes.</p>

<p>There are several approaches to skeletonizing a mesh. Which one to pick depends
(among other things) on the shape of your mesh and the skeleton quality you want
to get out of it. In general, unless you mesh already looks like a tube I
recommend looking into mesh contraction <sup class="footnote-ref" id="fnref-1"><a href="#fn-1">4</a></sup>.</p>

<p>Please see the documentation of the individual functions for details but here
is a quick summary:</p>

<table>
<thead>
<tr>
  <th>function</th>
  <th style="text-align:center;">speed</th>
  <th style="text-align:center;">robust</th>
  <th style="text-align:center;">radii <sup class="footnote-ref" id="fnref-2"><a href="#fn-2">1</a></sup></th>
  <th style="text-align:center;">mesh map <sup class="footnote-ref" id="fnref-3"><a href="#fn-3">2</a></sup></th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code><a href="#by_wavefront">by_wavefront()</a></code></td>
  <td style="text-align:center;">+++</td>
  <td style="text-align:center;">++</td>
  <td style="text-align:center;">yes</td>
  <td style="text-align:center;">yes</td>
  <td>works well for tubular meshes</td>
</tr>
<tr>
  <td><code><a href="#by_vertex_clusters">by_vertex_clusters()</a></code></td>
  <td style="text-align:center;">++</td>
  <td style="text-align:center;">+</td>
  <td style="text-align:center;">no</td>
  <td style="text-align:center;">yes</td>
  <td>best with contracted meshes <sup class="footnote-ref" id="fnref-1"><a href="#fn-1">3</a></sup></td>
</tr>
<tr>
  <td><code><a href="#by_teasar">by_teasar()</a></code></td>
  <td style="text-align:center;">+</td>
  <td style="text-align:center;">++</td>
  <td style="text-align:center;">no</td>
  <td style="text-align:center;">yes</td>
  <td>works on mesh surface</td>
</tr>
<tr>
  <td><code><a href="#by_tangent_ball">by_tangent_ball()</a></code></td>
  <td style="text-align:center;">++</td>
  <td style="text-align:center;">0</td>
  <td style="text-align:center;">yes</td>
  <td style="text-align:center;">yes</td>
  <td>works with mesh normals</td>
</tr>
<tr>
  <td><code><a href="#by_edge_collapse">by_edge_collapse()</a></code></td>
  <td style="text-align:center;">-</td>
  <td style="text-align:center;">0</td>
  <td style="text-align:center;">no</td>
  <td style="text-align:center;">no</td>
  <td>published with [1] - never got this to work well</td>
</tr>
</tbody>
</table>

<h2 id="references">References</h2>

<p><code>[1] Au OK, Tai CL, Chu HK, Cohen-Or D, Lee TY. Skeleton extraction by mesh contraction. ACM Transactions on Graphics (TOG). 2008 Aug 1;27(3):44.</code></p>

<div class="footnotes">
<hr />
<ol>
<li id="fn-1">
<p>use <code><a href="pre.html#contract">skeletor.pre.contract()</a></code>&#160;<a href="#fnref-1" class="footnoteBackLink" title="Jump back to footnote 1 in the text.">&#8617;</a></p>
</li>

<li id="fn-1">
<p>use <code><a href="pre.html#contract">skeletor.pre.contract()</a></code>&#160;<a href="#fnref-1" class="footnoteBackLink" title="Jump back to footnote 2 in the text.">&#8617;</a></p>
</li>

<li id="fn-2">
<p>radii can also be added in postprocessing with <code><a href="post.html#radii">skeletor.post.radii()</a></code>&#160;<a href="#fnref-2" class="footnoteBackLink" title="Jump back to footnote 3 in the text.">&#8617;</a></p>
</li>

<li id="fn-3">
<p>a mapping from the meshes vertices to skeleton nodes&#160;<a href="#fnref-3" class="footnoteBackLink" title="Jump back to footnote 4 in the text.">&#8617;</a></p>
</li>
</ol>
</div>
</div>

                        <input id="mod-skeletonize-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">

                        <label class="view-source-button" for="mod-skeletonize-view-source"><span>View Source</span></label>

                        <div class="pdoc-code codehilite"><pre><span></span><span id="L-1"><a href="#L-1"><span class="linenos"> 1</span></a><span class="c1">#    This script is part of skeletor (http://www.github.com/navis-org/skeletor).</span>
</span><span id="L-2"><a href="#L-2"><span class="linenos"> 2</span></a><span class="c1">#    Copyright (C) 2018 Philipp Schlegel</span>
</span><span id="L-3"><a href="#L-3"><span class="linenos"> 3</span></a><span class="c1">#</span>
</span><span id="L-4"><a href="#L-4"><span class="linenos"> 4</span></a><span class="c1">#    This program is free software: you can redistribute it and/or modify</span>
</span><span id="L-5"><a href="#L-5"><span class="linenos"> 5</span></a><span class="c1">#    it under the terms of the GNU General Public License as published by</span>
</span><span id="L-6"><a href="#L-6"><span class="linenos"> 6</span></a><span class="c1">#    the Free Software Foundation, either version 3 of the License, or</span>
</span><span id="L-7"><a href="#L-7"><span class="linenos"> 7</span></a><span class="c1">#    (at your option) any later version.</span>
</span><span id="L-8"><a href="#L-8"><span class="linenos"> 8</span></a><span class="c1">#</span>
</span><span id="L-9"><a href="#L-9"><span class="linenos"> 9</span></a><span class="c1">#    This program is distributed in the hope that it will be useful,</span>
</span><span id="L-10"><a href="#L-10"><span class="linenos">10</span></a><span class="c1">#    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
</span><span id="L-11"><a href="#L-11"><span class="linenos">11</span></a><span class="c1">#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
</span><span id="L-12"><a href="#L-12"><span class="linenos">12</span></a><span class="c1">#    GNU General Public License for more details.</span>
</span><span id="L-13"><a href="#L-13"><span class="linenos">13</span></a><span class="c1">#</span>
</span><span id="L-14"><a href="#L-14"><span class="linenos">14</span></a><span class="c1">#    You should have received a copy of the GNU General Public License</span>
</span><span id="L-15"><a href="#L-15"><span class="linenos">15</span></a><span class="c1">#    along with this program.</span>
</span><span id="L-16"><a href="#L-16"><span class="linenos">16</span></a>
</span><span id="L-17"><a href="#L-17"><span class="linenos">17</span></a><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="L-18"><a href="#L-18"><span class="linenos">18</span></a><span class="sd">The `skeletor.skeletonize` module contains functions to for skeletonization</span>
</span><span id="L-19"><a href="#L-19"><span class="linenos">19</span></a><span class="sd">of meshes.</span>
</span><span id="L-20"><a href="#L-20"><span class="linenos">20</span></a>
</span><span id="L-21"><a href="#L-21"><span class="linenos">21</span></a><span class="sd">There are several approaches to skeletonizing a mesh. Which one to pick depends</span>
</span><span id="L-22"><a href="#L-22"><span class="linenos">22</span></a><span class="sd">(among other things) on the shape of your mesh and the skeleton quality you want</span>
</span><span id="L-23"><a href="#L-23"><span class="linenos">23</span></a><span class="sd">to get out of it. In general, unless you mesh already looks like a tube I</span>
</span><span id="L-24"><a href="#L-24"><span class="linenos">24</span></a><span class="sd">recommend looking into mesh contraction [^1].</span>
</span><span id="L-25"><a href="#L-25"><span class="linenos">25</span></a>
</span><span id="L-26"><a href="#L-26"><span class="linenos">26</span></a><span class="sd">Please see the documentation of the individual functions for details but here</span>
</span><span id="L-27"><a href="#L-27"><span class="linenos">27</span></a><span class="sd">is a quick summary:</span>
</span><span id="L-28"><a href="#L-28"><span class="linenos">28</span></a>
</span><span id="L-29"><a href="#L-29"><span class="linenos">29</span></a><span class="sd">| function                                    | speed | robust | radii [^2] | mesh map [^3] | description                                        |</span>
</span><span id="L-30"><a href="#L-30"><span class="linenos">30</span></a><span class="sd">| ------------------------------------------- | :---: | :----: | :--------: | :-----------: | ---------------------------------------------------|</span>
</span><span id="L-31"><a href="#L-31"><span class="linenos">31</span></a><span class="sd">| `skeletor.skeletonize.by_wavefront()`       | +++   | ++     | yes        | yes           | works well for tubular meshes                      |</span>
</span><span id="L-32"><a href="#L-32"><span class="linenos">32</span></a><span class="sd">| `skeletor.skeletonize.by_vertex_clusters()` | ++    | +      | no         | yes           | best with contracted meshes [^1]                   |</span>
</span><span id="L-33"><a href="#L-33"><span class="linenos">33</span></a><span class="sd">| `skeletor.skeletonize.by_teasar()`          | +     | ++     | no         | yes           | works on mesh surface                              |</span>
</span><span id="L-34"><a href="#L-34"><span class="linenos">34</span></a><span class="sd">| `skeletor.skeletonize.by_tangent_ball()`    | ++    | 0      | yes        | yes           | works with mesh normals                            |</span>
</span><span id="L-35"><a href="#L-35"><span class="linenos">35</span></a><span class="sd">| `skeletor.skeletonize.by_edge_collapse()`   | -     | 0      | no         | no            | published with [1] - never got this to work well   |</span>
</span><span id="L-36"><a href="#L-36"><span class="linenos">36</span></a>
</span><span id="L-37"><a href="#L-37"><span class="linenos">37</span></a><span class="sd">[^1]: use `skeletor.pre.contract()`</span>
</span><span id="L-38"><a href="#L-38"><span class="linenos">38</span></a><span class="sd">[^2]: radii can also be added in postprocessing with `skeletor.post.radii()`</span>
</span><span id="L-39"><a href="#L-39"><span class="linenos">39</span></a><span class="sd">[^3]: a mapping from the meshes vertices to skeleton nodes</span>
</span><span id="L-40"><a href="#L-40"><span class="linenos">40</span></a>
</span><span id="L-41"><a href="#L-41"><span class="linenos">41</span></a><span class="sd">## References</span>
</span><span id="L-42"><a href="#L-42"><span class="linenos">42</span></a>
</span><span id="L-43"><a href="#L-43"><span class="linenos">43</span></a><span class="sd">`[1] Au OK, Tai CL, Chu HK, Cohen-Or D, Lee TY. Skeleton extraction by mesh contraction. ACM Transactions on Graphics (TOG). 2008 Aug 1;27(3):44.`</span>
</span><span id="L-44"><a href="#L-44"><span class="linenos">44</span></a>
</span><span id="L-45"><a href="#L-45"><span class="linenos">45</span></a><span class="sd">&quot;&quot;&quot;</span>
</span><span id="L-46"><a href="#L-46"><span class="linenos">46</span></a>
</span><span id="L-47"><a href="#L-47"><span class="linenos">47</span></a><span class="kn">from</span> <span class="nn">.edge_collapse</span> <span class="kn">import</span> <span class="o">*</span>
</span><span id="L-48"><a href="#L-48"><span class="linenos">48</span></a><span class="kn">from</span> <span class="nn">.vertex_cluster</span> <span class="kn">import</span> <span class="o">*</span>
</span><span id="L-49"><a href="#L-49"><span class="linenos">49</span></a><span class="kn">from</span> <span class="nn">.wave</span> <span class="kn">import</span> <span class="o">*</span>
</span><span id="L-50"><a href="#L-50"><span class="linenos">50</span></a><span class="kn">from</span> <span class="nn">.teasar</span> <span class="kn">import</span> <span class="o">*</span>
</span><span id="L-51"><a href="#L-51"><span class="linenos">51</span></a><span class="kn">from</span> <span class="nn">.tangent_ball</span> <span class="kn">import</span> <span class="o">*</span>
</span><span id="L-52"><a href="#L-52"><span class="linenos">52</span></a>
</span><span id="L-53"><a href="#L-53"><span class="linenos">53</span></a><span class="n">__docformat__</span> <span class="o">=</span> <span class="s2">&quot;numpy&quot;</span>
</span><span id="L-54"><a href="#L-54"><span class="linenos">54</span></a><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;by_teasar&#39;</span><span class="p">,</span> <span class="s1">&#39;by_wavefront&#39;</span><span class="p">,</span> <span class="s1">&#39;by_vertex_clusters&#39;</span><span class="p">,</span>
</span><span id="L-55"><a href="#L-55"><span class="linenos">55</span></a>           <span class="s1">&#39;by_edge_collapse&#39;</span><span class="p">,</span> <span class="s1">&#39;by_tangent_ball&#39;</span><span class="p">]</span>
</span></pre></div>


            </section>
                <section id="by_teasar">
                            <input id="by_teasar-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">by_teasar</span><span class="signature pdoc-code condensed">(<span class="param"><span class="n">mesh</span>, </span><span class="param"><span class="n">inv_dist</span>, </span><span class="param"><span class="n">min_length</span><span class="o">=</span><span class="kc">None</span>, </span><span class="param"><span class="n">root</span><span class="o">=</span><span class="kc">None</span>, </span><span class="param"><span class="n">progress</span><span class="o">=</span><span class="kc">True</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="by_teasar-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#by_teasar"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="by_teasar-39"><a href="#by_teasar-39"><span class="linenos"> 39</span></a><span class="k">def</span> <span class="nf">by_teasar</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">inv_dist</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="by_teasar-40"><a href="#by_teasar-40"><span class="linenos"> 40</span></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;Skeletonize a mesh mesh using the TEASAR algorithm [1].</span>
</span><span id="by_teasar-41"><a href="#by_teasar-41"><span class="linenos"> 41</span></a>
</span><span id="by_teasar-42"><a href="#by_teasar-42"><span class="linenos"> 42</span></a><span class="sd">    This algorithm finds the longest path from a root vertex, invalidates all</span>
</span><span id="by_teasar-43"><a href="#by_teasar-43"><span class="linenos"> 43</span></a><span class="sd">    vertices that are within `inv_dist`. Then picks the second longest (and</span>
</span><span id="by_teasar-44"><a href="#by_teasar-44"><span class="linenos"> 44</span></a><span class="sd">    still valid) path and does the same. Rinse &amp; repeat until all vertices have</span>
</span><span id="by_teasar-45"><a href="#by_teasar-45"><span class="linenos"> 45</span></a><span class="sd">    been invalidated. It&#39;s fast + works very well with tubular meshes, and with</span>
</span><span id="by_teasar-46"><a href="#by_teasar-46"><span class="linenos"> 46</span></a><span class="sd">    `inv_dist` you have control over the level of detail. Note that by its</span>
</span><span id="by_teasar-47"><a href="#by_teasar-47"><span class="linenos"> 47</span></a><span class="sd">    nature the skeleton will be exactly on the surface of the mesh.</span>
</span><span id="by_teasar-48"><a href="#by_teasar-48"><span class="linenos"> 48</span></a>
</span><span id="by_teasar-49"><a href="#by_teasar-49"><span class="linenos"> 49</span></a><span class="sd">    Based on the implementation by Sven Dorkenwald, Casey Schneider-Mizell and</span>
</span><span id="by_teasar-50"><a href="#by_teasar-50"><span class="linenos"> 50</span></a><span class="sd">    Forrest Collman in `meshparty` (https://github.com/sdorkenw/MeshParty).</span>
</span><span id="by_teasar-51"><a href="#by_teasar-51"><span class="linenos"> 51</span></a>
</span><span id="by_teasar-52"><a href="#by_teasar-52"><span class="linenos"> 52</span></a><span class="sd">    Parameters</span>
</span><span id="by_teasar-53"><a href="#by_teasar-53"><span class="linenos"> 53</span></a><span class="sd">    ----------</span>
</span><span id="by_teasar-54"><a href="#by_teasar-54"><span class="linenos"> 54</span></a><span class="sd">    mesh :          mesh obj</span>
</span><span id="by_teasar-55"><a href="#by_teasar-55"><span class="linenos"> 55</span></a><span class="sd">                    The mesh to be skeletonize. Can an object that has</span>
</span><span id="by_teasar-56"><a href="#by_teasar-56"><span class="linenos"> 56</span></a><span class="sd">                    ``.vertices`` and ``.faces`` properties  (e.g. a</span>
</span><span id="by_teasar-57"><a href="#by_teasar-57"><span class="linenos"> 57</span></a><span class="sd">                    trimesh.Trimesh) or a tuple ``(vertices, faces)`` or a</span>
</span><span id="by_teasar-58"><a href="#by_teasar-58"><span class="linenos"> 58</span></a><span class="sd">                    dictionary ``{&#39;vertices&#39;: vertices, &#39;faces&#39;: faces}``.</span>
</span><span id="by_teasar-59"><a href="#by_teasar-59"><span class="linenos"> 59</span></a><span class="sd">    inv_dist :      int | float</span>
</span><span id="by_teasar-60"><a href="#by_teasar-60"><span class="linenos"> 60</span></a><span class="sd">                    Distance along the mesh used for invalidation of vertices.</span>
</span><span id="by_teasar-61"><a href="#by_teasar-61"><span class="linenos"> 61</span></a><span class="sd">                    This controls how detailed (or noisy) the skeleton will be.</span>
</span><span id="by_teasar-62"><a href="#by_teasar-62"><span class="linenos"> 62</span></a><span class="sd">    min_length :    float, optional</span>
</span><span id="by_teasar-63"><a href="#by_teasar-63"><span class="linenos"> 63</span></a><span class="sd">                    If provided, will skip any branch that is shorter than</span>
</span><span id="by_teasar-64"><a href="#by_teasar-64"><span class="linenos"> 64</span></a><span class="sd">                    `min_length`. Use this to get rid of noise but note that</span>
</span><span id="by_teasar-65"><a href="#by_teasar-65"><span class="linenos"> 65</span></a><span class="sd">                    it will lead to vertices not being mapped to skeleton nodes.</span>
</span><span id="by_teasar-66"><a href="#by_teasar-66"><span class="linenos"> 66</span></a><span class="sd">                    Such vertices will show up with index -1 in</span>
</span><span id="by_teasar-67"><a href="#by_teasar-67"><span class="linenos"> 67</span></a><span class="sd">                    `Skeleton.mesh_map`.</span>
</span><span id="by_teasar-68"><a href="#by_teasar-68"><span class="linenos"> 68</span></a><span class="sd">    root :          int, optional</span>
</span><span id="by_teasar-69"><a href="#by_teasar-69"><span class="linenos"> 69</span></a><span class="sd">                    Vertex ID of a root. If not provided will use ``0``.</span>
</span><span id="by_teasar-70"><a href="#by_teasar-70"><span class="linenos"> 70</span></a><span class="sd">    progress :      bool, optional</span>
</span><span id="by_teasar-71"><a href="#by_teasar-71"><span class="linenos"> 71</span></a><span class="sd">                    If True, will show progress bar.</span>
</span><span id="by_teasar-72"><a href="#by_teasar-72"><span class="linenos"> 72</span></a>
</span><span id="by_teasar-73"><a href="#by_teasar-73"><span class="linenos"> 73</span></a><span class="sd">    Returns</span>
</span><span id="by_teasar-74"><a href="#by_teasar-74"><span class="linenos"> 74</span></a><span class="sd">    -------</span>
</span><span id="by_teasar-75"><a href="#by_teasar-75"><span class="linenos"> 75</span></a><span class="sd">    skeletor.Skeleton</span>
</span><span id="by_teasar-76"><a href="#by_teasar-76"><span class="linenos"> 76</span></a><span class="sd">                    Holds results of the skeletonization and enables quick</span>
</span><span id="by_teasar-77"><a href="#by_teasar-77"><span class="linenos"> 77</span></a><span class="sd">                    visualization.</span>
</span><span id="by_teasar-78"><a href="#by_teasar-78"><span class="linenos"> 78</span></a>
</span><span id="by_teasar-79"><a href="#by_teasar-79"><span class="linenos"> 79</span></a><span class="sd">    References</span>
</span><span id="by_teasar-80"><a href="#by_teasar-80"><span class="linenos"> 80</span></a><span class="sd">    ----------</span>
</span><span id="by_teasar-81"><a href="#by_teasar-81"><span class="linenos"> 81</span></a><span class="sd">    [1] Sato, M., Bitter, I., Bender, M. A., Kaufman, A. E., &amp; Nakajima, M.</span>
</span><span id="by_teasar-82"><a href="#by_teasar-82"><span class="linenos"> 82</span></a><span class="sd">        (n.d.). TEASAR: tree-structure extraction algorithm for accurate and</span>
</span><span id="by_teasar-83"><a href="#by_teasar-83"><span class="linenos"> 83</span></a><span class="sd">        robust skeletons. In Proceedings the Eighth Pacific Conference on</span>
</span><span id="by_teasar-84"><a href="#by_teasar-84"><span class="linenos"> 84</span></a><span class="sd">        Computer Graphics and Applications. IEEE Comput. Soc.</span>
</span><span id="by_teasar-85"><a href="#by_teasar-85"><span class="linenos"> 85</span></a><span class="sd">        https://doi.org/10.1109/pccga.2000.883951</span>
</span><span id="by_teasar-86"><a href="#by_teasar-86"><span class="linenos"> 86</span></a>
</span><span id="by_teasar-87"><a href="#by_teasar-87"><span class="linenos"> 87</span></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="by_teasar-88"><a href="#by_teasar-88"><span class="linenos"> 88</span></a>    <span class="n">mesh</span> <span class="o">=</span> <span class="n">make_trimesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="by_teasar-89"><a href="#by_teasar-89"><span class="linenos"> 89</span></a>
</span><span id="by_teasar-90"><a href="#by_teasar-90"><span class="linenos"> 90</span></a>    <span class="c1"># Generate Graph (must be undirected)</span>
</span><span id="by_teasar-91"><a href="#by_teasar-91"><span class="linenos"> 91</span></a>    <span class="n">G</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="by_teasar-92"><a href="#by_teasar-92"><span class="linenos"> 92</span></a>    <span class="n">G</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique_length</span>
</span><span id="by_teasar-93"><a href="#by_teasar-93"><span class="linenos"> 93</span></a>
</span><span id="by_teasar-94"><a href="#by_teasar-94"><span class="linenos"> 94</span></a>    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
</span><span id="by_teasar-95"><a href="#by_teasar-95"><span class="linenos"> 95</span></a>        <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span>
</span><span id="by_teasar-96"><a href="#by_teasar-96"><span class="linenos"> 96</span></a>
</span><span id="by_teasar-97"><a href="#by_teasar-97"><span class="linenos"> 97</span></a>    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
</span><span id="by_teasar-98"><a href="#by_teasar-98"><span class="linenos"> 98</span></a>    <span class="n">mesh_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</span><span id="by_teasar-99"><a href="#by_teasar-99"><span class="linenos"> 99</span></a>
</span><span id="by_teasar-100"><a href="#by_teasar-100"><span class="linenos">100</span></a>    <span class="k">with</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Invalidating&#39;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vs</span><span class="p">),</span>
</span><span id="by_teasar-101"><a href="#by_teasar-101"><span class="linenos">101</span></a>              <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress</span><span class="p">,</span> <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
</span><span id="by_teasar-102"><a href="#by_teasar-102"><span class="linenos">102</span></a>        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">clusters</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="by_teasar-103"><a href="#by_teasar-103"><span class="linenos">103</span></a>            <span class="c1"># Make a subgraph for this connected component</span>
</span><span id="by_teasar-104"><a href="#by_teasar-104"><span class="linenos">104</span></a>            <span class="n">SG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
</span><span id="by_teasar-105"><a href="#by_teasar-105"><span class="linenos">105</span></a>            <span class="n">cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
</span><span id="by_teasar-106"><a href="#by_teasar-106"><span class="linenos">106</span></a>
</span><span id="by_teasar-107"><a href="#by_teasar-107"><span class="linenos">107</span></a>            <span class="c1"># Find root within subgraph</span>
</span><span id="by_teasar-108"><a href="#by_teasar-108"><span class="linenos">108</span></a>            <span class="k">if</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">:</span>
</span><span id="by_teasar-109"><a href="#by_teasar-109"><span class="linenos">109</span></a>                <span class="n">this_root</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cc</span> <span class="o">==</span> <span class="n">root</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</span><span id="by_teasar-110"><a href="#by_teasar-110"><span class="linenos">110</span></a>            <span class="k">else</span><span class="p">:</span>
</span><span id="by_teasar-111"><a href="#by_teasar-111"><span class="linenos">111</span></a>                <span class="n">this_root</span> <span class="o">=</span> <span class="mi">0</span>
</span><span id="by_teasar-112"><a href="#by_teasar-112"><span class="linenos">112</span></a>
</span><span id="by_teasar-113"><a href="#by_teasar-113"><span class="linenos">113</span></a>            <span class="c1"># Get the sparse adjacency matrix of the subgraph</span>
</span><span id="by_teasar-114"><a href="#by_teasar-114"><span class="linenos">114</span></a>            <span class="n">sp</span> <span class="o">=</span> <span class="n">SG</span><span class="o">.</span><span class="n">get_adjacency_sparse</span><span class="p">(</span><span class="s1">&#39;weight&#39;</span><span class="p">)</span>
</span><span id="by_teasar-115"><a href="#by_teasar-115"><span class="linenos">115</span></a>
</span><span id="by_teasar-116"><a href="#by_teasar-116"><span class="linenos">116</span></a>            <span class="c1"># Get lengths of paths to all nodes from root</span>
</span><span id="by_teasar-117"><a href="#by_teasar-117"><span class="linenos">117</span></a>            <span class="n">paths</span> <span class="o">=</span> <span class="n">SG</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="n">this_root</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span>
</span><span id="by_teasar-118"><a href="#by_teasar-118"><span class="linenos">118</span></a>                                      <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;ALL&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="by_teasar-119"><a href="#by_teasar-119"><span class="linenos">119</span></a>            <span class="n">paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
</span><span id="by_teasar-120"><a href="#by_teasar-120"><span class="linenos">120</span></a>
</span><span id="by_teasar-121"><a href="#by_teasar-121"><span class="linenos">121</span></a>            <span class="c1"># Prep array for invalidation</span>
</span><span id="by_teasar-122"><a href="#by_teasar-122"><span class="linenos">122</span></a>            <span class="n">valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">paths</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
</span><span id="by_teasar-123"><a href="#by_teasar-123"><span class="linenos">123</span></a>            <span class="n">invalidated</span> <span class="o">=</span> <span class="mi">0</span>
</span><span id="by_teasar-124"><a href="#by_teasar-124"><span class="linenos">124</span></a>
</span><span id="by_teasar-125"><a href="#by_teasar-125"><span class="linenos">125</span></a>            <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">valid</span><span class="p">):</span>
</span><span id="by_teasar-126"><a href="#by_teasar-126"><span class="linenos">126</span></a>                <span class="c1"># Find the farthest point</span>
</span><span id="by_teasar-127"><a href="#by_teasar-127"><span class="linenos">127</span></a>                <span class="n">farthest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
</span><span id="by_teasar-128"><a href="#by_teasar-128"><span class="linenos">128</span></a>
</span><span id="by_teasar-129"><a href="#by_teasar-129"><span class="linenos">129</span></a>                <span class="c1"># Get path from root to farthest point</span>
</span><span id="by_teasar-130"><a href="#by_teasar-130"><span class="linenos">130</span></a>                <span class="n">path</span> <span class="o">=</span> <span class="n">SG</span><span class="o">.</span><span class="n">get_shortest_paths</span><span class="p">(</span><span class="n">this_root</span><span class="p">,</span> <span class="n">farthest</span><span class="p">,</span>
</span><span id="by_teasar-131"><a href="#by_teasar-131"><span class="linenos">131</span></a>                                             <span class="n">weights</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;ALL&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="by_teasar-132"><a href="#by_teasar-132"><span class="linenos">132</span></a>
</span><span id="by_teasar-133"><a href="#by_teasar-133"><span class="linenos">133</span></a>                <span class="c1"># Get IDs of edges along the path</span>
</span><span id="by_teasar-134"><a href="#by_teasar-134"><span class="linenos">134</span></a>                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ig</span><span class="p">,</span> <span class="s1">&#39;__version_info__&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
</span><span id="by_teasar-135"><a href="#by_teasar-135"><span class="linenos">135</span></a>                    <span class="n">pairs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</span><span id="by_teasar-136"><a href="#by_teasar-136"><span class="linenos">136</span></a>                    <span class="n">eids</span> <span class="o">=</span> <span class="n">SG</span><span class="o">.</span><span class="n">get_eids</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="by_teasar-137"><a href="#by_teasar-137"><span class="linenos">137</span></a>                <span class="k">else</span><span class="p">:</span>
</span><span id="by_teasar-138"><a href="#by_teasar-138"><span class="linenos">138</span></a>                    <span class="n">eids</span> <span class="o">=</span> <span class="n">SG</span><span class="o">.</span><span class="n">get_eids</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="by_teasar-139"><a href="#by_teasar-139"><span class="linenos">139</span></a>
</span><span id="by_teasar-140"><a href="#by_teasar-140"><span class="linenos">140</span></a>                <span class="c1"># Stop if farthest point is closer than min_length</span>
</span><span id="by_teasar-141"><a href="#by_teasar-141"><span class="linenos">141</span></a>                <span class="n">add</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="by_teasar-142"><a href="#by_teasar-142"><span class="linenos">142</span></a>                <span class="k">if</span> <span class="n">min_length</span><span class="p">:</span>
</span><span id="by_teasar-143"><a href="#by_teasar-143"><span class="linenos">143</span></a>                    <span class="c1"># This should only be distance to the first branchpoint</span>
</span><span id="by_teasar-144"><a href="#by_teasar-144"><span class="linenos">144</span></a>                    <span class="c1"># from the tip since we set other weights to zero</span>
</span><span id="by_teasar-145"><a href="#by_teasar-145"><span class="linenos">145</span></a>                    <span class="n">le</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">SG</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="n">eids</span><span class="p">]</span><span class="o">.</span><span class="n">get_attribute_values</span><span class="p">(</span><span class="s1">&#39;weight&#39;</span><span class="p">))</span>
</span><span id="by_teasar-146"><a href="#by_teasar-146"><span class="linenos">146</span></a>                    <span class="k">if</span> <span class="n">le</span> <span class="o">&lt;</span> <span class="n">min_length</span><span class="p">:</span>
</span><span id="by_teasar-147"><a href="#by_teasar-147"><span class="linenos">147</span></a>                        <span class="n">add</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="by_teasar-148"><a href="#by_teasar-148"><span class="linenos">148</span></a>
</span><span id="by_teasar-149"><a href="#by_teasar-149"><span class="linenos">149</span></a>                <span class="k">if</span> <span class="n">add</span><span class="p">:</span>
</span><span id="by_teasar-150"><a href="#by_teasar-150"><span class="linenos">150</span></a>                    <span class="c1"># Add these new edges</span>
</span><span id="by_teasar-151"><a href="#by_teasar-151"><span class="linenos">151</span></a>                    <span class="n">new_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">cc</span><span class="p">[</span><span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">cc</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]))</span><span class="o">.</span><span class="n">T</span>
</span><span id="by_teasar-152"><a href="#by_teasar-152"><span class="linenos">152</span></a>                    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span><span id="by_teasar-153"><a href="#by_teasar-153"><span class="linenos">153</span></a>
</span><span id="by_teasar-154"><a href="#by_teasar-154"><span class="linenos">154</span></a>                <span class="c1"># Invalidate points in the path</span>
</span><span id="by_teasar-155"><a href="#by_teasar-155"><span class="linenos">155</span></a>                <span class="n">valid</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="by_teasar-156"><a href="#by_teasar-156"><span class="linenos">156</span></a>                <span class="n">paths</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</span><span id="by_teasar-157"><a href="#by_teasar-157"><span class="linenos">157</span></a>
</span><span id="by_teasar-158"><a href="#by_teasar-158"><span class="linenos">158</span></a>                <span class="c1"># Must set weights along path to 0 so that this path is</span>
</span><span id="by_teasar-159"><a href="#by_teasar-159"><span class="linenos">159</span></a>                <span class="c1"># taken again in future iterations</span>
</span><span id="by_teasar-160"><a href="#by_teasar-160"><span class="linenos">160</span></a>                <span class="n">SG</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="n">eids</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</span><span id="by_teasar-161"><a href="#by_teasar-161"><span class="linenos">161</span></a>
</span><span id="by_teasar-162"><a href="#by_teasar-162"><span class="linenos">162</span></a>                <span class="c1"># Get all nodes within `inv_dist` to this path</span>
</span><span id="by_teasar-163"><a href="#by_teasar-163"><span class="linenos">163</span></a>                <span class="c1"># Note: can we somehow only include still valid nodes to speed</span>
</span><span id="by_teasar-164"><a href="#by_teasar-164"><span class="linenos">164</span></a>                <span class="c1"># things up?</span>
</span><span id="by_teasar-165"><a href="#by_teasar-165"><span class="linenos">165</span></a>                <span class="n">dist</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">sources</span> <span class="o">=</span> <span class="n">dijkstra</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">path</span><span class="p">,</span>
</span><span id="by_teasar-166"><a href="#by_teasar-166"><span class="linenos">166</span></a>                                            <span class="n">limit</span><span class="o">=</span><span class="n">inv_dist</span><span class="p">,</span> <span class="n">min_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
</span><span id="by_teasar-167"><a href="#by_teasar-167"><span class="linenos">167</span></a>                                            <span class="n">return_predecessors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="by_teasar-168"><a href="#by_teasar-168"><span class="linenos">168</span></a>
</span><span id="by_teasar-169"><a href="#by_teasar-169"><span class="linenos">169</span></a>                <span class="c1"># Invalidate</span>
</span><span id="by_teasar-170"><a href="#by_teasar-170"><span class="linenos">170</span></a>                <span class="n">in_dist</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">inv_dist</span>
</span><span id="by_teasar-171"><a href="#by_teasar-171"><span class="linenos">171</span></a>                <span class="n">to_invalidate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">in_dist</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="by_teasar-172"><a href="#by_teasar-172"><span class="linenos">172</span></a>                <span class="n">valid</span><span class="p">[</span><span class="n">to_invalidate</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="by_teasar-173"><a href="#by_teasar-173"><span class="linenos">173</span></a>                <span class="n">paths</span><span class="p">[</span><span class="n">to_invalidate</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</span><span id="by_teasar-174"><a href="#by_teasar-174"><span class="linenos">174</span></a>
</span><span id="by_teasar-175"><a href="#by_teasar-175"><span class="linenos">175</span></a>                <span class="c1"># Update mesh vertex to skeleton node map</span>
</span><span id="by_teasar-176"><a href="#by_teasar-176"><span class="linenos">176</span></a>                <span class="n">mesh_map</span><span class="p">[</span><span class="n">cc</span><span class="p">[</span><span class="n">in_dist</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cc</span><span class="p">[</span><span class="n">sources</span><span class="p">[</span><span class="n">in_dist</span><span class="p">]]</span>
</span><span id="by_teasar-177"><a href="#by_teasar-177"><span class="linenos">177</span></a>
</span><span id="by_teasar-178"><a href="#by_teasar-178"><span class="linenos">178</span></a>                <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="o">~</span><span class="n">valid</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">invalidated</span><span class="p">)</span>
</span><span id="by_teasar-179"><a href="#by_teasar-179"><span class="linenos">179</span></a>                <span class="n">invalidated</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">valid</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
</span><span id="by_teasar-180"><a href="#by_teasar-180"><span class="linenos">180</span></a>
</span><span id="by_teasar-181"><a href="#by_teasar-181"><span class="linenos">181</span></a>    <span class="c1"># Make unique edges (paths will have overlapped!)</span>
</span><span id="by_teasar-182"><a href="#by_teasar-182"><span class="linenos">182</span></a>    <span class="n">edges</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span><span id="by_teasar-183"><a href="#by_teasar-183"><span class="linenos">183</span></a>
</span><span id="by_teasar-184"><a href="#by_teasar-184"><span class="linenos">184</span></a>    <span class="c1"># Create a directed acyclic and hierarchical graph</span>
</span><span id="by_teasar-185"><a href="#by_teasar-185"><span class="linenos">185</span></a>    <span class="n">G_nx</span> <span class="o">=</span> <span class="n">edges_to_graph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
</span><span id="by_teasar-186"><a href="#by_teasar-186"><span class="linenos">186</span></a>                          <span class="n">fix_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fix_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
</span><span id="by_teasar-187"><a href="#by_teasar-187"><span class="linenos">187</span></a>                          <span class="n">weight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="by_teasar-188"><a href="#by_teasar-188"><span class="linenos">188</span></a>
</span><span id="by_teasar-189"><a href="#by_teasar-189"><span class="linenos">189</span></a>    <span class="c1"># Generate the SWC table</span>
</span><span id="by_teasar-190"><a href="#by_teasar-190"><span class="linenos">190</span></a>    <span class="n">swc</span><span class="p">,</span> <span class="n">new_ids</span> <span class="o">=</span> <span class="n">make_swc</span><span class="p">(</span><span class="n">G_nx</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">reindex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="by_teasar-191"><a href="#by_teasar-191"><span class="linenos">191</span></a>
</span><span id="by_teasar-192"><a href="#by_teasar-192"><span class="linenos">192</span></a>    <span class="c1"># Update vertex to node ID map</span>
</span><span id="by_teasar-193"><a href="#by_teasar-193"><span class="linenos">193</span></a>    <span class="n">mesh_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_ids</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mesh_map</span><span class="p">])</span>
</span><span id="by_teasar-194"><a href="#by_teasar-194"><span class="linenos">194</span></a>
</span><span id="by_teasar-195"><a href="#by_teasar-195"><span class="linenos">195</span></a>    <span class="k">return</span> <span class="n">Skeleton</span><span class="p">(</span><span class="n">swc</span><span class="o">=</span><span class="n">swc</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh_map</span><span class="o">=</span><span class="n">mesh_map</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;teasar&#39;</span><span class="p">)</span>
</span></pre></div>


            <div class="docstring"><p>Skeletonize a mesh mesh using the TEASAR algorithm [1].</p>

<p>This algorithm finds the longest path from a root vertex, invalidates all
vertices that are within <code>inv_dist</code>. Then picks the second longest (and
still valid) path and does the same. Rinse &amp; repeat until all vertices have
been invalidated. It's fast + works very well with tubular meshes, and with
<code>inv_dist</code> you have control over the level of detail. Note that by its
nature the skeleton will be exactly on the surface of the mesh.</p>

<p>Based on the implementation by Sven Dorkenwald, Casey Schneider-Mizell and
Forrest Collman in <code>meshparty</code> (https://github.com/sdorkenw/MeshParty).</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>mesh</strong> (mesh obj):
The mesh to be skeletonize. Can an object that has
<code>.vertices</code> and <code>.faces</code> properties  (e.g. a
trimesh.Trimesh) or a tuple <code>(vertices, faces)</code> or a
dictionary <code>{'vertices': vertices, 'faces': faces}</code>.</li>
<li><strong>inv_dist</strong> (int | float):
Distance along the mesh used for invalidation of vertices.
This controls how detailed (or noisy) the skeleton will be.</li>
<li><strong>min_length</strong> (float, optional):
If provided, will skip any branch that is shorter than
<code>min_length</code>. Use this to get rid of noise but note that
it will lead to vertices not being mapped to skeleton nodes.
Such vertices will show up with index -1 in
<code>Skeleton.mesh_map</code>.</li>
<li><strong>root</strong> (int, optional):
Vertex ID of a root. If not provided will use <code>0</code>.</li>
<li><strong>progress</strong> (bool, optional):
If True, will show progress bar.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong><a href="../skeletor.html#Skeleton">skeletor.Skeleton</a></strong>: Holds results of the skeletonization and enables quick
visualization.</li>
</ul>

<h6 id="references">References</h6>

<p>[1] Sato, M., Bitter, I., Bender, M. A., Kaufman, A. E., &amp; Nakajima, M.
    (n.d.). TEASAR: tree-structure extraction algorithm for accurate and
    robust skeletons. In Proceedings the Eighth Pacific Conference on
    Computer Graphics and Applications. IEEE Comput. Soc.
    <a href="https://doi.org/10.1109/pccga.2000.883951">https://doi.org/10.1109/pccga.2000.883951</a></p>
</div>


                </section>
                <section id="by_wavefront">
                            <input id="by_wavefront-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">by_wavefront</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="n">mesh</span>,</span><span class="param">	<span class="n">waves</span><span class="o">=</span><span class="mi">1</span>,</span><span class="param">	<span class="n">origins</span><span class="o">=</span><span class="kc">None</span>,</span><span class="param">	<span class="n">step_size</span><span class="o">=</span><span class="mi">1</span>,</span><span class="param">	<span class="n">radius_agg</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span>,</span><span class="param">	<span class="n">progress</span><span class="o">=</span><span class="kc">True</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="by_wavefront-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#by_wavefront"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="by_wavefront-39"><a href="#by_wavefront-39"><span class="linenos"> 39</span></a><span class="k">def</span> <span class="nf">by_wavefront</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
</span><span id="by_wavefront-40"><a href="#by_wavefront-40"><span class="linenos"> 40</span></a>                 <span class="n">waves</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
</span><span id="by_wavefront-41"><a href="#by_wavefront-41"><span class="linenos"> 41</span></a>                 <span class="n">origins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
</span><span id="by_wavefront-42"><a href="#by_wavefront-42"><span class="linenos"> 42</span></a>                 <span class="n">step_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
</span><span id="by_wavefront-43"><a href="#by_wavefront-43"><span class="linenos"> 43</span></a>                 <span class="n">radius_agg</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span>
</span><span id="by_wavefront-44"><a href="#by_wavefront-44"><span class="linenos"> 44</span></a>                 <span class="n">progress</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="by_wavefront-45"><a href="#by_wavefront-45"><span class="linenos"> 45</span></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;Skeletonize a mesh using wave fronts.</span>
</span><span id="by_wavefront-46"><a href="#by_wavefront-46"><span class="linenos"> 46</span></a>
</span><span id="by_wavefront-47"><a href="#by_wavefront-47"><span class="linenos"> 47</span></a><span class="sd">    The algorithm tries to find rings of vertices and collapse them to</span>
</span><span id="by_wavefront-48"><a href="#by_wavefront-48"><span class="linenos"> 48</span></a><span class="sd">    their center. This is done by propagating a wave across the mesh starting at</span>
</span><span id="by_wavefront-49"><a href="#by_wavefront-49"><span class="linenos"> 49</span></a><span class="sd">    a single seed vertex. As the wave travels across the mesh we keep track of</span>
</span><span id="by_wavefront-50"><a href="#by_wavefront-50"><span class="linenos"> 50</span></a><span class="sd">    which vertices are are encountered at each step. Groups of connected</span>
</span><span id="by_wavefront-51"><a href="#by_wavefront-51"><span class="linenos"> 51</span></a><span class="sd">    vertices that are &quot;hit&quot; by the wave at the same time are considered rings</span>
</span><span id="by_wavefront-52"><a href="#by_wavefront-52"><span class="linenos"> 52</span></a><span class="sd">    and subsequently collapsed. By its nature this works best with tubular meshes.</span>
</span><span id="by_wavefront-53"><a href="#by_wavefront-53"><span class="linenos"> 53</span></a>
</span><span id="by_wavefront-54"><a href="#by_wavefront-54"><span class="linenos"> 54</span></a><span class="sd">    Parameters</span>
</span><span id="by_wavefront-55"><a href="#by_wavefront-55"><span class="linenos"> 55</span></a><span class="sd">    ----------</span>
</span><span id="by_wavefront-56"><a href="#by_wavefront-56"><span class="linenos"> 56</span></a><span class="sd">    mesh :          mesh obj</span>
</span><span id="by_wavefront-57"><a href="#by_wavefront-57"><span class="linenos"> 57</span></a><span class="sd">                    The mesh to be skeletonize. Can an object that has</span>
</span><span id="by_wavefront-58"><a href="#by_wavefront-58"><span class="linenos"> 58</span></a><span class="sd">                    ``.vertices`` and ``.faces`` properties  (e.g. a</span>
</span><span id="by_wavefront-59"><a href="#by_wavefront-59"><span class="linenos"> 59</span></a><span class="sd">                    trimesh.Trimesh) or a tuple ``(vertices, faces)`` or a</span>
</span><span id="by_wavefront-60"><a href="#by_wavefront-60"><span class="linenos"> 60</span></a><span class="sd">                    dictionary ``{&#39;vertices&#39;: vertices, &#39;faces&#39;: faces}``.</span>
</span><span id="by_wavefront-61"><a href="#by_wavefront-61"><span class="linenos"> 61</span></a><span class="sd">    waves :         int</span>
</span><span id="by_wavefront-62"><a href="#by_wavefront-62"><span class="linenos"> 62</span></a><span class="sd">                    Number of waves to run across the mesh. Each wave is</span>
</span><span id="by_wavefront-63"><a href="#by_wavefront-63"><span class="linenos"> 63</span></a><span class="sd">                    initialized at a different vertex which produces slightly</span>
</span><span id="by_wavefront-64"><a href="#by_wavefront-64"><span class="linenos"> 64</span></a><span class="sd">                    different rings. The final skeleton is produced from a mean</span>
</span><span id="by_wavefront-65"><a href="#by_wavefront-65"><span class="linenos"> 65</span></a><span class="sd">                    across all waves. More waves produce higher resolution</span>
</span><span id="by_wavefront-66"><a href="#by_wavefront-66"><span class="linenos"> 66</span></a><span class="sd">                    skeletons but also introduce more noise.</span>
</span><span id="by_wavefront-67"><a href="#by_wavefront-67"><span class="linenos"> 67</span></a><span class="sd">    origins :       int | list of ints, optional</span>
</span><span id="by_wavefront-68"><a href="#by_wavefront-68"><span class="linenos"> 68</span></a><span class="sd">                    Vertex ID(s) where the wave(s) are initialized. If we run</span>
</span><span id="by_wavefront-69"><a href="#by_wavefront-69"><span class="linenos"> 69</span></a><span class="sd">                    out of origins (either because less `origins` than `waves`</span>
</span><span id="by_wavefront-70"><a href="#by_wavefront-70"><span class="linenos"> 70</span></a><span class="sd">                    or because no origin for one of the connected components)</span>
</span><span id="by_wavefront-71"><a href="#by_wavefront-71"><span class="linenos"> 71</span></a><span class="sd">                    will fall back to semi-random origin.</span>
</span><span id="by_wavefront-72"><a href="#by_wavefront-72"><span class="linenos"> 72</span></a><span class="sd">    step_size :     int</span>
</span><span id="by_wavefront-73"><a href="#by_wavefront-73"><span class="linenos"> 73</span></a><span class="sd">                    Values greater 1 effectively lead to binning of rings. For</span>
</span><span id="by_wavefront-74"><a href="#by_wavefront-74"><span class="linenos"> 74</span></a><span class="sd">                    example a stepsize of 2 means that two adjacent vertex rings</span>
</span><span id="by_wavefront-75"><a href="#by_wavefront-75"><span class="linenos"> 75</span></a><span class="sd">                    will be collapsed to the same center. This can help reduce</span>
</span><span id="by_wavefront-76"><a href="#by_wavefront-76"><span class="linenos"> 76</span></a><span class="sd">                    noise in the skeleton (and as such counteracts a large</span>
</span><span id="by_wavefront-77"><a href="#by_wavefront-77"><span class="linenos"> 77</span></a><span class="sd">                    number of waves).</span>
</span><span id="by_wavefront-78"><a href="#by_wavefront-78"><span class="linenos"> 78</span></a><span class="sd">    radius_agg :    &quot;mean&quot; | &quot;median&quot; | &quot;max&quot; | &quot;min&quot; | &quot;percentile75&quot; | &quot;percentile25&quot;</span>
</span><span id="by_wavefront-79"><a href="#by_wavefront-79"><span class="linenos"> 79</span></a><span class="sd">                    Function used to aggregate radii over sample (i.e. the</span>
</span><span id="by_wavefront-80"><a href="#by_wavefront-80"><span class="linenos"> 80</span></a><span class="sd">                    vertices forming a ring that we collapse to its center).</span>
</span><span id="by_wavefront-81"><a href="#by_wavefront-81"><span class="linenos"> 81</span></a><span class="sd">    progress :      bool</span>
</span><span id="by_wavefront-82"><a href="#by_wavefront-82"><span class="linenos"> 82</span></a><span class="sd">                    If True, will show progress bar.</span>
</span><span id="by_wavefront-83"><a href="#by_wavefront-83"><span class="linenos"> 83</span></a>
</span><span id="by_wavefront-84"><a href="#by_wavefront-84"><span class="linenos"> 84</span></a><span class="sd">    Returns</span>
</span><span id="by_wavefront-85"><a href="#by_wavefront-85"><span class="linenos"> 85</span></a><span class="sd">    -------</span>
</span><span id="by_wavefront-86"><a href="#by_wavefront-86"><span class="linenos"> 86</span></a><span class="sd">    skeletor.Skeleton</span>
</span><span id="by_wavefront-87"><a href="#by_wavefront-87"><span class="linenos"> 87</span></a><span class="sd">                    Holds results of the skeletonization and enables quick</span>
</span><span id="by_wavefront-88"><a href="#by_wavefront-88"><span class="linenos"> 88</span></a><span class="sd">                    visualization.</span>
</span><span id="by_wavefront-89"><a href="#by_wavefront-89"><span class="linenos"> 89</span></a>
</span><span id="by_wavefront-90"><a href="#by_wavefront-90"><span class="linenos"> 90</span></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="by_wavefront-91"><a href="#by_wavefront-91"><span class="linenos"> 91</span></a>    <span class="n">agg_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span>
</span><span id="by_wavefront-92"><a href="#by_wavefront-92"><span class="linenos"> 92</span></a>               <span class="s1">&#39;median&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">,</span>
</span><span id="by_wavefront-93"><a href="#by_wavefront-93"><span class="linenos"> 93</span></a>               <span class="s1">&#39;percentile75&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">75</span><span class="p">),</span>
</span><span id="by_wavefront-94"><a href="#by_wavefront-94"><span class="linenos"> 94</span></a>               <span class="s1">&#39;percentile25&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">25</span><span class="p">)}</span>
</span><span id="by_wavefront-95"><a href="#by_wavefront-95"><span class="linenos"> 95</span></a>    <span class="k">assert</span> <span class="n">radius_agg</span> <span class="ow">in</span> <span class="n">agg_map</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Unknown `radius_agg`: &quot;</span><span class="si">{</span><span class="n">radius_agg</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
</span><span id="by_wavefront-96"><a href="#by_wavefront-96"><span class="linenos"> 96</span></a>    <span class="n">rad_agg_func</span> <span class="o">=</span> <span class="n">agg_map</span><span class="p">[</span><span class="n">radius_agg</span><span class="p">]</span>
</span><span id="by_wavefront-97"><a href="#by_wavefront-97"><span class="linenos"> 97</span></a>
</span><span id="by_wavefront-98"><a href="#by_wavefront-98"><span class="linenos"> 98</span></a>    <span class="n">mesh</span> <span class="o">=</span> <span class="n">make_trimesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="by_wavefront-99"><a href="#by_wavefront-99"><span class="linenos"> 99</span></a>
</span><span id="by_wavefront-100"><a href="#by_wavefront-100"><span class="linenos">100</span></a>    <span class="n">centers_final</span><span class="p">,</span> <span class="n">radii_final</span><span class="p">,</span> <span class="n">G</span> <span class="o">=</span> <span class="n">_cast_waves</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">waves</span><span class="o">=</span><span class="n">waves</span><span class="p">,</span>
</span><span id="by_wavefront-101"><a href="#by_wavefront-101"><span class="linenos">101</span></a>                                                <span class="n">origins</span><span class="o">=</span><span class="n">origins</span><span class="p">,</span>
</span><span id="by_wavefront-102"><a href="#by_wavefront-102"><span class="linenos">102</span></a>                                                <span class="n">step_size</span><span class="o">=</span><span class="n">step_size</span><span class="p">,</span>
</span><span id="by_wavefront-103"><a href="#by_wavefront-103"><span class="linenos">103</span></a>                                                <span class="n">rad_agg_func</span><span class="o">=</span><span class="n">rad_agg_func</span><span class="p">,</span>
</span><span id="by_wavefront-104"><a href="#by_wavefront-104"><span class="linenos">104</span></a>                                                <span class="n">progress</span><span class="o">=</span><span class="n">progress</span><span class="p">)</span>
</span><span id="by_wavefront-105"><a href="#by_wavefront-105"><span class="linenos">105</span></a>
</span><span id="by_wavefront-106"><a href="#by_wavefront-106"><span class="linenos">106</span></a>    <span class="c1"># Collapse vertices into nodes</span>
</span><span id="by_wavefront-107"><a href="#by_wavefront-107"><span class="linenos">107</span></a>    <span class="p">(</span><span class="n">node_centers</span><span class="p">,</span>
</span><span id="by_wavefront-108"><a href="#by_wavefront-108"><span class="linenos">108</span></a>     <span class="n">vertex_to_node_map</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">centers_final</span><span class="p">,</span>
</span><span id="by_wavefront-109"><a href="#by_wavefront-109"><span class="linenos">109</span></a>                                     <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span><span id="by_wavefront-110"><a href="#by_wavefront-110"><span class="linenos">110</span></a>
</span><span id="by_wavefront-111"><a href="#by_wavefront-111"><span class="linenos">111</span></a>    <span class="c1"># Map radii for individual vertices to the collapsed nodes</span>
</span><span id="by_wavefront-112"><a href="#by_wavefront-112"><span class="linenos">112</span></a>    <span class="c1"># Using pandas is the fastest way here</span>
</span><span id="by_wavefront-113"><a href="#by_wavefront-113"><span class="linenos">113</span></a>    <span class="n">node_radii</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
</span><span id="by_wavefront-114"><a href="#by_wavefront-114"><span class="linenos">114</span></a>    <span class="n">node_radii</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertex_to_node_map</span>
</span><span id="by_wavefront-115"><a href="#by_wavefront-115"><span class="linenos">115</span></a>    <span class="n">node_radii</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">radii_final</span>
</span><span id="by_wavefront-116"><a href="#by_wavefront-116"><span class="linenos">116</span></a>    <span class="n">node_radii</span> <span class="o">=</span> <span class="n">node_radii</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;node_id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">radius</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">rad_agg_func</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
</span><span id="by_wavefront-117"><a href="#by_wavefront-117"><span class="linenos">117</span></a>
</span><span id="by_wavefront-118"><a href="#by_wavefront-118"><span class="linenos">118</span></a>    <span class="c1"># Contract vertices</span>
</span><span id="by_wavefront-119"><a href="#by_wavefront-119"><span class="linenos">119</span></a>    <span class="n">G</span><span class="o">.</span><span class="n">contract_vertices</span><span class="p">(</span><span class="n">vertex_to_node_map</span><span class="p">)</span>
</span><span id="by_wavefront-120"><a href="#by_wavefront-120"><span class="linenos">120</span></a>
</span><span id="by_wavefront-121"><a href="#by_wavefront-121"><span class="linenos">121</span></a>    <span class="c1"># Remove self loops and duplicate edges</span>
</span><span id="by_wavefront-122"><a href="#by_wavefront-122"><span class="linenos">122</span></a>    <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
</span><span id="by_wavefront-123"><a href="#by_wavefront-123"><span class="linenos">123</span></a>
</span><span id="by_wavefront-124"><a href="#by_wavefront-124"><span class="linenos">124</span></a>    <span class="c1"># Generate hierarchical tree</span>
</span><span id="by_wavefront-125"><a href="#by_wavefront-125"><span class="linenos">125</span></a>    <span class="n">el</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">get_edgelist</span><span class="p">())</span>
</span><span id="by_wavefront-126"><a href="#by_wavefront-126"><span class="linenos">126</span></a>
</span><span id="by_wavefront-127"><a href="#by_wavefront-127"><span class="linenos">127</span></a>    <span class="k">if</span> <span class="n">PRESERVE_BACKBONE</span><span class="p">:</span>
</span><span id="by_wavefront-128"><a href="#by_wavefront-128"><span class="linenos">128</span></a>        <span class="c1"># Use the minimum radius between vertices in an edge</span>
</span><span id="by_wavefront-129"><a href="#by_wavefront-129"><span class="linenos">129</span></a>        <span class="n">weights_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">node_radii</span><span class="p">[</span><span class="n">el</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]],</span>
</span><span id="by_wavefront-130"><a href="#by_wavefront-130"><span class="linenos">130</span></a>                                 <span class="n">node_radii</span><span class="p">[</span><span class="n">el</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span><span id="by_wavefront-131"><a href="#by_wavefront-131"><span class="linenos">131</span></a>
</span><span id="by_wavefront-132"><a href="#by_wavefront-132"><span class="linenos">132</span></a>        <span class="c1"># For each node generate a vector based on its immediate neighbors</span>
</span><span id="by_wavefront-133"><a href="#by_wavefront-133"><span class="linenos">133</span></a>        <span class="n">vect</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">dotprops</span><span class="p">(</span><span class="n">node_centers</span><span class="p">)</span>
</span><span id="by_wavefront-134"><a href="#by_wavefront-134"><span class="linenos">134</span></a>        <span class="n">weights_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">alpha</span><span class="p">[</span><span class="n">el</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]],</span>
</span><span id="by_wavefront-135"><a href="#by_wavefront-135"><span class="linenos">135</span></a>                                   <span class="n">alpha</span><span class="p">[</span><span class="n">el</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span><span id="by_wavefront-136"><a href="#by_wavefront-136"><span class="linenos">136</span></a>
</span><span id="by_wavefront-137"><a href="#by_wavefront-137"><span class="linenos">137</span></a>        <span class="c1"># Combine both which means we are most likely to cut at small branches</span>
</span><span id="by_wavefront-138"><a href="#by_wavefront-138"><span class="linenos">138</span></a>        <span class="c1"># outside of the backbone</span>
</span><span id="by_wavefront-139"><a href="#by_wavefront-139"><span class="linenos">139</span></a>        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights_rad</span> <span class="o">*</span> <span class="n">weights_alpha</span>
</span><span id="by_wavefront-140"><a href="#by_wavefront-140"><span class="linenos">140</span></a>
</span><span id="by_wavefront-141"><a href="#by_wavefront-141"><span class="linenos">141</span></a>        <span class="c1"># MST doesn&#39;t like 0 for weights</span>
</span><span id="by_wavefront-142"><a href="#by_wavefront-142"><span class="linenos">142</span></a>        <span class="n">weights</span><span class="p">[</span><span class="n">weights</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">weights</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>
</span><span id="by_wavefront-143"><a href="#by_wavefront-143"><span class="linenos">143</span></a>
</span><span id="by_wavefront-144"><a href="#by_wavefront-144"><span class="linenos">144</span></a>    <span class="k">else</span><span class="p">:</span>
</span><span id="by_wavefront-145"><a href="#by_wavefront-145"><span class="linenos">145</span></a>        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">node_centers</span><span class="p">[</span><span class="n">el</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">node_centers</span><span class="p">[</span><span class="n">el</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span><span id="by_wavefront-146"><a href="#by_wavefront-146"><span class="linenos">146</span></a>    <span class="n">tree</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spanning_tree</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="n">weights</span><span class="p">)</span>
</span><span id="by_wavefront-147"><a href="#by_wavefront-147"><span class="linenos">147</span></a>
</span><span id="by_wavefront-148"><a href="#by_wavefront-148"><span class="linenos">148</span></a>    <span class="c1"># Create a directed acyclic and hierarchical graph</span>
</span><span id="by_wavefront-149"><a href="#by_wavefront-149"><span class="linenos">149</span></a>    <span class="n">G_nx</span> <span class="o">=</span> <span class="n">edges_to_graph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">get_edgelist</span><span class="p">()),</span>
</span><span id="by_wavefront-150"><a href="#by_wavefront-150"><span class="linenos">150</span></a>                          <span class="n">nodes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vs</span><span class="p">)),</span>
</span><span id="by_wavefront-151"><a href="#by_wavefront-151"><span class="linenos">151</span></a>                          <span class="n">fix_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># this makes sure graph is oriented</span>
</span><span id="by_wavefront-152"><a href="#by_wavefront-152"><span class="linenos">152</span></a>                          <span class="n">drop_disconnected</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="by_wavefront-153"><a href="#by_wavefront-153"><span class="linenos">153</span></a>
</span><span id="by_wavefront-154"><a href="#by_wavefront-154"><span class="linenos">154</span></a>    <span class="c1"># Generate the SWC table</span>
</span><span id="by_wavefront-155"><a href="#by_wavefront-155"><span class="linenos">155</span></a>    <span class="n">swc</span> <span class="o">=</span> <span class="n">make_swc</span><span class="p">(</span><span class="n">G_nx</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">node_centers</span><span class="p">,</span> <span class="n">reindex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="by_wavefront-156"><a href="#by_wavefront-156"><span class="linenos">156</span></a>    <span class="n">swc</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_radii</span><span class="p">[</span><span class="n">swc</span><span class="o">.</span><span class="n">node_id</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>
</span><span id="by_wavefront-157"><a href="#by_wavefront-157"><span class="linenos">157</span></a>    <span class="n">_</span><span class="p">,</span> <span class="n">new_ids</span> <span class="o">=</span> <span class="n">reindex_swc</span><span class="p">(</span><span class="n">swc</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="by_wavefront-158"><a href="#by_wavefront-158"><span class="linenos">158</span></a>
</span><span id="by_wavefront-159"><a href="#by_wavefront-159"><span class="linenos">159</span></a>    <span class="c1"># Update vertex to node ID map</span>
</span><span id="by_wavefront-160"><a href="#by_wavefront-160"><span class="linenos">160</span></a>    <span class="n">vertex_to_node_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_ids</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">vertex_to_node_map</span><span class="p">])</span>
</span><span id="by_wavefront-161"><a href="#by_wavefront-161"><span class="linenos">161</span></a>
</span><span id="by_wavefront-162"><a href="#by_wavefront-162"><span class="linenos">162</span></a>    <span class="k">return</span> <span class="n">Skeleton</span><span class="p">(</span><span class="n">swc</span><span class="o">=</span><span class="n">swc</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh_map</span><span class="o">=</span><span class="n">vertex_to_node_map</span><span class="p">,</span>
</span><span id="by_wavefront-163"><a href="#by_wavefront-163"><span class="linenos">163</span></a>                    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;wavefront&#39;</span><span class="p">)</span>
</span></pre></div>


            <div class="docstring"><p>Skeletonize a mesh using wave fronts.</p>

<p>The algorithm tries to find rings of vertices and collapse them to
their center. This is done by propagating a wave across the mesh starting at
a single seed vertex. As the wave travels across the mesh we keep track of
which vertices are are encountered at each step. Groups of connected
vertices that are "hit" by the wave at the same time are considered rings
and subsequently collapsed. By its nature this works best with tubular meshes.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>mesh</strong> (mesh obj):
The mesh to be skeletonize. Can an object that has
<code>.vertices</code> and <code>.faces</code> properties  (e.g. a
trimesh.Trimesh) or a tuple <code>(vertices, faces)</code> or a
dictionary <code>{'vertices': vertices, 'faces': faces}</code>.</li>
<li><strong>waves</strong> (int):
Number of waves to run across the mesh. Each wave is
initialized at a different vertex which produces slightly
different rings. The final skeleton is produced from a mean
across all waves. More waves produce higher resolution
skeletons but also introduce more noise.</li>
<li><strong>origins</strong> (int | list of ints, optional):
Vertex ID(s) where the wave(s) are initialized. If we run
out of origins (either because less <code>origins</code> than <code>waves</code>
or because no origin for one of the connected components)
will fall back to semi-random origin.</li>
<li><strong>step_size</strong> (int):
Values greater 1 effectively lead to binning of rings. For
example a stepsize of 2 means that two adjacent vertex rings
will be collapsed to the same center. This can help reduce
noise in the skeleton (and as such counteracts a large
number of waves).</li>
<li><strong>radius_agg</strong> ("mean" | "median" | "max" | "min" | "percentile75" | "percentile25"):
Function used to aggregate radii over sample (i.e. the
vertices forming a ring that we collapse to its center).</li>
<li><strong>progress</strong> (bool):
If True, will show progress bar.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong><a href="../skeletor.html#Skeleton">skeletor.Skeleton</a></strong>: Holds results of the skeletonization and enables quick
visualization.</li>
</ul>
</div>


                </section>
                <section id="by_vertex_clusters">
                            <input id="by_vertex_clusters-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">by_vertex_clusters</span><span class="signature pdoc-code condensed">(<span class="param"><span class="n">mesh</span>, </span><span class="param"><span class="n">sampling_dist</span>, </span><span class="param"><span class="n">cluster_pos</span><span class="o">=</span><span class="s1">&#39;median&#39;</span>, </span><span class="param"><span class="n">progress</span><span class="o">=</span><span class="kc">True</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="by_vertex_clusters-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#by_vertex_clusters"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="by_vertex_clusters-40"><a href="#by_vertex_clusters-40"><span class="linenos"> 40</span></a><span class="k">def</span> <span class="nf">by_vertex_clusters</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">sampling_dist</span><span class="p">,</span> <span class="n">cluster_pos</span><span class="o">=</span><span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="by_vertex_clusters-41"><a href="#by_vertex_clusters-41"><span class="linenos"> 41</span></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;Skeletonize a (contracted) mesh by clustering vertices.</span>
</span><span id="by_vertex_clusters-42"><a href="#by_vertex_clusters-42"><span class="linenos"> 42</span></a>
</span><span id="by_vertex_clusters-43"><a href="#by_vertex_clusters-43"><span class="linenos"> 43</span></a><span class="sd">    The algorithm traverses the mesh graph and groups vertices together that</span>
</span><span id="by_vertex_clusters-44"><a href="#by_vertex_clusters-44"><span class="linenos"> 44</span></a><span class="sd">    are within a given distance to each other. This uses the geodesic</span>
</span><span id="by_vertex_clusters-45"><a href="#by_vertex_clusters-45"><span class="linenos"> 45</span></a><span class="sd">    (along-the-mesh) distance, not simply the Euclidean distance. Subsequently</span>
</span><span id="by_vertex_clusters-46"><a href="#by_vertex_clusters-46"><span class="linenos"> 46</span></a><span class="sd">    these groups of vertices are collapsed and re-connected respecting the</span>
</span><span id="by_vertex_clusters-47"><a href="#by_vertex_clusters-47"><span class="linenos"> 47</span></a><span class="sd">    topology of the input mesh.</span>
</span><span id="by_vertex_clusters-48"><a href="#by_vertex_clusters-48"><span class="linenos"> 48</span></a>
</span><span id="by_vertex_clusters-49"><a href="#by_vertex_clusters-49"><span class="linenos"> 49</span></a><span class="sd">    The graph traversal is fast and scales well, so this method is well suited</span>
</span><span id="by_vertex_clusters-50"><a href="#by_vertex_clusters-50"><span class="linenos"> 50</span></a><span class="sd">    for meshes with lots of vertices. On the downside: this implementation is</span>
</span><span id="by_vertex_clusters-51"><a href="#by_vertex_clusters-51"><span class="linenos"> 51</span></a><span class="sd">    not very clever and you might have to play around with the parameters</span>
</span><span id="by_vertex_clusters-52"><a href="#by_vertex_clusters-52"><span class="linenos"> 52</span></a><span class="sd">    (mostly ``sampling_dist``) to get decent results.</span>
</span><span id="by_vertex_clusters-53"><a href="#by_vertex_clusters-53"><span class="linenos"> 53</span></a>
</span><span id="by_vertex_clusters-54"><a href="#by_vertex_clusters-54"><span class="linenos"> 54</span></a><span class="sd">    Parameters</span>
</span><span id="by_vertex_clusters-55"><a href="#by_vertex_clusters-55"><span class="linenos"> 55</span></a><span class="sd">    ----------</span>
</span><span id="by_vertex_clusters-56"><a href="#by_vertex_clusters-56"><span class="linenos"> 56</span></a><span class="sd">    mesh :          mesh obj</span>
</span><span id="by_vertex_clusters-57"><a href="#by_vertex_clusters-57"><span class="linenos"> 57</span></a><span class="sd">                    The mesh to be skeletonize. Can an object that has</span>
</span><span id="by_vertex_clusters-58"><a href="#by_vertex_clusters-58"><span class="linenos"> 58</span></a><span class="sd">                    ``.vertices`` and ``.faces`` properties  (e.g. a</span>
</span><span id="by_vertex_clusters-59"><a href="#by_vertex_clusters-59"><span class="linenos"> 59</span></a><span class="sd">                    trimesh.Trimesh) or a tuple ``(vertices, faces)`` or a</span>
</span><span id="by_vertex_clusters-60"><a href="#by_vertex_clusters-60"><span class="linenos"> 60</span></a><span class="sd">                    dictionary ``{&#39;vertices&#39;: vertices, &#39;faces&#39;: faces}``.</span>
</span><span id="by_vertex_clusters-61"><a href="#by_vertex_clusters-61"><span class="linenos"> 61</span></a><span class="sd">    sampling_dist : float | int</span>
</span><span id="by_vertex_clusters-62"><a href="#by_vertex_clusters-62"><span class="linenos"> 62</span></a><span class="sd">                    Maximal distance at which vertices are clustered. This</span>
</span><span id="by_vertex_clusters-63"><a href="#by_vertex_clusters-63"><span class="linenos"> 63</span></a><span class="sd">                    parameter should be tuned based on the resolution of your</span>
</span><span id="by_vertex_clusters-64"><a href="#by_vertex_clusters-64"><span class="linenos"> 64</span></a><span class="sd">                    mesh (see Examples).</span>
</span><span id="by_vertex_clusters-65"><a href="#by_vertex_clusters-65"><span class="linenos"> 65</span></a><span class="sd">    cluster_pos :   &quot;median&quot; | &quot;center&quot;</span>
</span><span id="by_vertex_clusters-66"><a href="#by_vertex_clusters-66"><span class="linenos"> 66</span></a><span class="sd">                    How to determine the x/y/z coordinates of the collapsed</span>
</span><span id="by_vertex_clusters-67"><a href="#by_vertex_clusters-67"><span class="linenos"> 67</span></a><span class="sd">                    vertex clusters (i.e. the skeleton&#39;s nodes)::</span>
</span><span id="by_vertex_clusters-68"><a href="#by_vertex_clusters-68"><span class="linenos"> 68</span></a>
</span><span id="by_vertex_clusters-69"><a href="#by_vertex_clusters-69"><span class="linenos"> 69</span></a><span class="sd">                      - &quot;median&quot;: Use the vertex closest to cluster&#39;s center of</span>
</span><span id="by_vertex_clusters-70"><a href="#by_vertex_clusters-70"><span class="linenos"> 70</span></a><span class="sd">                        mass.</span>
</span><span id="by_vertex_clusters-71"><a href="#by_vertex_clusters-71"><span class="linenos"> 71</span></a><span class="sd">                      - &quot;center&quot;: Use the center of mass. This makes for smoother</span>
</span><span id="by_vertex_clusters-72"><a href="#by_vertex_clusters-72"><span class="linenos"> 72</span></a><span class="sd">                        skeletons but can lead to nodes outside the mesh.</span>
</span><span id="by_vertex_clusters-73"><a href="#by_vertex_clusters-73"><span class="linenos"> 73</span></a><span class="sd">    progress :      bool</span>
</span><span id="by_vertex_clusters-74"><a href="#by_vertex_clusters-74"><span class="linenos"> 74</span></a><span class="sd">                    If True, will show progress bar.</span>
</span><span id="by_vertex_clusters-75"><a href="#by_vertex_clusters-75"><span class="linenos"> 75</span></a>
</span><span id="by_vertex_clusters-76"><a href="#by_vertex_clusters-76"><span class="linenos"> 76</span></a><span class="sd">    Examples</span>
</span><span id="by_vertex_clusters-77"><a href="#by_vertex_clusters-77"><span class="linenos"> 77</span></a><span class="sd">    --------</span>
</span><span id="by_vertex_clusters-78"><a href="#by_vertex_clusters-78"><span class="linenos"> 78</span></a><span class="sd">    &gt;&gt;&gt; import skeletor as sk</span>
</span><span id="by_vertex_clusters-79"><a href="#by_vertex_clusters-79"><span class="linenos"> 79</span></a><span class="sd">    &gt;&gt;&gt; mesh = sk.example_mesh()</span>
</span><span id="by_vertex_clusters-80"><a href="#by_vertex_clusters-80"><span class="linenos"> 80</span></a><span class="sd">    &gt;&gt;&gt; cont = sk.pre.contract(mesh, epsilon=0.1)</span>
</span><span id="by_vertex_clusters-81"><a href="#by_vertex_clusters-81"><span class="linenos"> 81</span></a><span class="sd">    &gt;&gt;&gt; skel = sk.skeletonize.vertex_cluster(cont)</span>
</span><span id="by_vertex_clusters-82"><a href="#by_vertex_clusters-82"><span class="linenos"> 82</span></a><span class="sd">    &gt;&gt;&gt; skel.mesh = mesh</span>
</span><span id="by_vertex_clusters-83"><a href="#by_vertex_clusters-83"><span class="linenos"> 83</span></a>
</span><span id="by_vertex_clusters-84"><a href="#by_vertex_clusters-84"><span class="linenos"> 84</span></a><span class="sd">    Returns</span>
</span><span id="by_vertex_clusters-85"><a href="#by_vertex_clusters-85"><span class="linenos"> 85</span></a><span class="sd">    -------</span>
</span><span id="by_vertex_clusters-86"><a href="#by_vertex_clusters-86"><span class="linenos"> 86</span></a><span class="sd">    skeletor.Skeleton</span>
</span><span id="by_vertex_clusters-87"><a href="#by_vertex_clusters-87"><span class="linenos"> 87</span></a><span class="sd">                    Holds results of the skeletonization and enables quick</span>
</span><span id="by_vertex_clusters-88"><a href="#by_vertex_clusters-88"><span class="linenos"> 88</span></a><span class="sd">                    visualization.</span>
</span><span id="by_vertex_clusters-89"><a href="#by_vertex_clusters-89"><span class="linenos"> 89</span></a>
</span><span id="by_vertex_clusters-90"><a href="#by_vertex_clusters-90"><span class="linenos"> 90</span></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="by_vertex_clusters-91"><a href="#by_vertex_clusters-91"><span class="linenos"> 91</span></a>    <span class="k">assert</span> <span class="n">cluster_pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">]</span>
</span><span id="by_vertex_clusters-92"><a href="#by_vertex_clusters-92"><span class="linenos"> 92</span></a>
</span><span id="by_vertex_clusters-93"><a href="#by_vertex_clusters-93"><span class="linenos"> 93</span></a>    <span class="n">mesh</span> <span class="o">=</span> <span class="n">make_trimesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="by_vertex_clusters-94"><a href="#by_vertex_clusters-94"><span class="linenos"> 94</span></a>
</span><span id="by_vertex_clusters-95"><a href="#by_vertex_clusters-95"><span class="linenos"> 95</span></a>    <span class="c1"># Produce weighted edges</span>
</span><span id="by_vertex_clusters-96"><a href="#by_vertex_clusters-96"><span class="linenos"> 96</span></a>    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">,</span>
</span><span id="by_vertex_clusters-97"><a href="#by_vertex_clusters-97"><span class="linenos"> 97</span></a>                            <span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique_length</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span>
</span><span id="by_vertex_clusters-98"><a href="#by_vertex_clusters-98"><span class="linenos"> 98</span></a>                           <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span><span id="by_vertex_clusters-99"><a href="#by_vertex_clusters-99"><span class="linenos"> 99</span></a>
</span><span id="by_vertex_clusters-100"><a href="#by_vertex_clusters-100"><span class="linenos">100</span></a>    <span class="c1"># Generate Graph (must be undirected)</span>
</span><span id="by_vertex_clusters-101"><a href="#by_vertex_clusters-101"><span class="linenos">101</span></a>    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
</span><span id="by_vertex_clusters-102"><a href="#by_vertex_clusters-102"><span class="linenos">102</span></a>    <span class="n">G</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
</span><span id="by_vertex_clusters-103"><a href="#by_vertex_clusters-103"><span class="linenos">103</span></a>
</span><span id="by_vertex_clusters-104"><a href="#by_vertex_clusters-104"><span class="linenos">104</span></a>    <span class="c1"># Run the graph traversal that groups vertices into spatial clusters</span>
</span><span id="by_vertex_clusters-105"><a href="#by_vertex_clusters-105"><span class="linenos">105</span></a>    <span class="n">not_visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
</span><span id="by_vertex_clusters-106"><a href="#by_vertex_clusters-106"><span class="linenos">106</span></a>    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="by_vertex_clusters-107"><a href="#by_vertex_clusters-107"><span class="linenos">107</span></a>    <span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="by_vertex_clusters-108"><a href="#by_vertex_clusters-108"><span class="linenos">108</span></a>    <span class="n">to_visit</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_visited</span><span class="p">)</span>
</span><span id="by_vertex_clusters-109"><a href="#by_vertex_clusters-109"><span class="linenos">109</span></a>    <span class="k">with</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Clustering&#39;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">not_visited</span><span class="p">),</span> <span class="n">disable</span><span class="o">=</span><span class="n">progress</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
</span><span id="by_vertex_clusters-110"><a href="#by_vertex_clusters-110"><span class="linenos">110</span></a>        <span class="k">while</span> <span class="n">not_visited</span><span class="p">:</span>
</span><span id="by_vertex_clusters-111"><a href="#by_vertex_clusters-111"><span class="linenos">111</span></a>            <span class="c1"># Pick a random node</span>
</span><span id="by_vertex_clusters-112"><a href="#by_vertex_clusters-112"><span class="linenos">112</span></a>            <span class="n">start</span> <span class="o">=</span> <span class="n">not_visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</span><span id="by_vertex_clusters-113"><a href="#by_vertex_clusters-113"><span class="linenos">113</span></a>            <span class="c1"># Get all nodes in the geodesic vicinity</span>
</span><span id="by_vertex_clusters-114"><a href="#by_vertex_clusters-114"><span class="linenos">114</span></a>            <span class="n">cl</span><span class="p">,</span> <span class="n">seen</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">dist_traveled</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
</span><span id="by_vertex_clusters-115"><a href="#by_vertex_clusters-115"><span class="linenos">115</span></a>                           <span class="n">max_dist</span><span class="o">=</span><span class="n">sampling_dist</span><span class="p">,</span> <span class="n">seen</span><span class="o">=</span><span class="n">seen</span><span class="p">)</span>
</span><span id="by_vertex_clusters-116"><a href="#by_vertex_clusters-116"><span class="linenos">116</span></a>            <span class="n">cl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">cl</span><span class="p">)</span>
</span><span id="by_vertex_clusters-117"><a href="#by_vertex_clusters-117"><span class="linenos">117</span></a>
</span><span id="by_vertex_clusters-118"><a href="#by_vertex_clusters-118"><span class="linenos">118</span></a>            <span class="c1"># Append this cluster and track visited/not-visited nodes</span>
</span><span id="by_vertex_clusters-119"><a href="#by_vertex_clusters-119"><span class="linenos">119</span></a>            <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cl</span><span class="p">)</span>
</span><span id="by_vertex_clusters-120"><a href="#by_vertex_clusters-120"><span class="linenos">120</span></a>            <span class="n">not_visited</span> <span class="o">=</span> <span class="n">not_visited</span> <span class="o">-</span> <span class="n">cl</span>
</span><span id="by_vertex_clusters-121"><a href="#by_vertex_clusters-121"><span class="linenos">121</span></a>
</span><span id="by_vertex_clusters-122"><a href="#by_vertex_clusters-122"><span class="linenos">122</span></a>            <span class="c1"># Update  progress bar</span>
</span><span id="by_vertex_clusters-123"><a href="#by_vertex_clusters-123"><span class="linenos">123</span></a>            <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">to_visit</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_visited</span><span class="p">))</span>
</span><span id="by_vertex_clusters-124"><a href="#by_vertex_clusters-124"><span class="linenos">124</span></a>            <span class="n">to_visit</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_visited</span><span class="p">)</span>
</span><span id="by_vertex_clusters-125"><a href="#by_vertex_clusters-125"><span class="linenos">125</span></a>
</span><span id="by_vertex_clusters-126"><a href="#by_vertex_clusters-126"><span class="linenos">126</span></a>    <span class="c1"># `clusters` is a list of sets -&gt; let&#39;s turn it into list of arrays</span>
</span><span id="by_vertex_clusters-127"><a href="#by_vertex_clusters-127"><span class="linenos">127</span></a>    <span class="n">clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">]</span>
</span><span id="by_vertex_clusters-128"><a href="#by_vertex_clusters-128"><span class="linenos">128</span></a>
</span><span id="by_vertex_clusters-129"><a href="#by_vertex_clusters-129"><span class="linenos">129</span></a>    <span class="c1"># Get positions of clusters</span>
</span><span id="by_vertex_clusters-130"><a href="#by_vertex_clusters-130"><span class="linenos">130</span></a>    <span class="k">if</span> <span class="n">cluster_pos</span> <span class="o">==</span> <span class="s1">&#39;center&#39;</span><span class="p">:</span>
</span><span id="by_vertex_clusters-131"><a href="#by_vertex_clusters-131"><span class="linenos">131</span></a>        <span class="c1"># Get the center of each cluster</span>
</span><span id="by_vertex_clusters-132"><a href="#by_vertex_clusters-132"><span class="linenos">132</span></a>        <span class="n">cl_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">])</span>
</span><span id="by_vertex_clusters-133"><a href="#by_vertex_clusters-133"><span class="linenos">133</span></a>    <span class="k">elif</span> <span class="n">cluster_pos</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
</span><span id="by_vertex_clusters-134"><a href="#by_vertex_clusters-134"><span class="linenos">134</span></a>        <span class="c1"># Get the node that&#39;s closest to to the clusters center</span>
</span><span id="by_vertex_clusters-135"><a href="#by_vertex_clusters-135"><span class="linenos">135</span></a>        <span class="n">cl_coords</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="by_vertex_clusters-136"><a href="#by_vertex_clusters-136"><span class="linenos">136</span></a>        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
</span><span id="by_vertex_clusters-137"><a href="#by_vertex_clusters-137"><span class="linenos">137</span></a>            <span class="n">cnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span><span id="by_vertex_clusters-138"><a href="#by_vertex_clusters-138"><span class="linenos">138</span></a>            <span class="n">cnt_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">cnt</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span><span id="by_vertex_clusters-139"><a href="#by_vertex_clusters-139"><span class="linenos">139</span></a>            <span class="n">median</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">cnt_dist</span><span class="p">)]</span>
</span><span id="by_vertex_clusters-140"><a href="#by_vertex_clusters-140"><span class="linenos">140</span></a>            <span class="n">cl_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">median</span><span class="p">)</span>
</span><span id="by_vertex_clusters-141"><a href="#by_vertex_clusters-141"><span class="linenos">141</span></a>        <span class="n">cl_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cl_coords</span><span class="p">)</span>
</span><span id="by_vertex_clusters-142"><a href="#by_vertex_clusters-142"><span class="linenos">142</span></a>
</span><span id="by_vertex_clusters-143"><a href="#by_vertex_clusters-143"><span class="linenos">143</span></a>    <span class="c1"># Generate edges</span>
</span><span id="by_vertex_clusters-144"><a href="#by_vertex_clusters-144"><span class="linenos">144</span></a>    <span class="n">cl_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">)</span>
</span><span id="by_vertex_clusters-145"><a href="#by_vertex_clusters-145"><span class="linenos">145</span></a>    <span class="k">if</span> <span class="n">fastremap</span><span class="p">:</span>
</span><span id="by_vertex_clusters-146"><a href="#by_vertex_clusters-146"><span class="linenos">146</span></a>        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">l</span><span class="p">}</span>
</span><span id="by_vertex_clusters-147"><a href="#by_vertex_clusters-147"><span class="linenos">147</span></a>        <span class="n">cl_edges</span> <span class="o">=</span> <span class="n">fastremap</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="n">cl_edges</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">preserve_missing_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="by_vertex_clusters-148"><a href="#by_vertex_clusters-148"><span class="linenos">148</span></a>    <span class="k">else</span><span class="p">:</span>
</span><span id="by_vertex_clusters-149"><a href="#by_vertex_clusters-149"><span class="linenos">149</span></a>        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">):</span>
</span><span id="by_vertex_clusters-150"><a href="#by_vertex_clusters-150"><span class="linenos">150</span></a>            <span class="n">cl_edges</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">cl_edges</span><span class="p">,</span> <span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="n">i</span>
</span><span id="by_vertex_clusters-151"><a href="#by_vertex_clusters-151"><span class="linenos">151</span></a>
</span><span id="by_vertex_clusters-152"><a href="#by_vertex_clusters-152"><span class="linenos">152</span></a>    <span class="c1"># Remove directionality from cluster edges</span>
</span><span id="by_vertex_clusters-153"><a href="#by_vertex_clusters-153"><span class="linenos">153</span></a>    <span class="n">cl_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">cl_edges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span><span id="by_vertex_clusters-154"><a href="#by_vertex_clusters-154"><span class="linenos">154</span></a>
</span><span id="by_vertex_clusters-155"><a href="#by_vertex_clusters-155"><span class="linenos">155</span></a>    <span class="c1"># Get unique edges</span>
</span><span id="by_vertex_clusters-156"><a href="#by_vertex_clusters-156"><span class="linenos">156</span></a>    <span class="n">cl_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cl_edges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span><span id="by_vertex_clusters-157"><a href="#by_vertex_clusters-157"><span class="linenos">157</span></a>
</span><span id="by_vertex_clusters-158"><a href="#by_vertex_clusters-158"><span class="linenos">158</span></a>    <span class="c1"># Calculate edge lengths</span>
</span><span id="by_vertex_clusters-159"><a href="#by_vertex_clusters-159"><span class="linenos">159</span></a>    <span class="n">co1</span> <span class="o">=</span> <span class="n">cl_coords</span><span class="p">[</span><span class="n">cl_edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
</span><span id="by_vertex_clusters-160"><a href="#by_vertex_clusters-160"><span class="linenos">160</span></a>    <span class="n">co2</span> <span class="o">=</span> <span class="n">cl_coords</span><span class="p">[</span><span class="n">cl_edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
</span><span id="by_vertex_clusters-161"><a href="#by_vertex_clusters-161"><span class="linenos">161</span></a>    <span class="n">cl_edge_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">co1</span> <span class="o">-</span> <span class="n">co2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</span><span id="by_vertex_clusters-162"><a href="#by_vertex_clusters-162"><span class="linenos">162</span></a>
</span><span id="by_vertex_clusters-163"><a href="#by_vertex_clusters-163"><span class="linenos">163</span></a>    <span class="c1"># Produce adjacency matrix from edges and edge lengths</span>
</span><span id="by_vertex_clusters-164"><a href="#by_vertex_clusters-164"><span class="linenos">164</span></a>    <span class="n">n_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
</span><span id="by_vertex_clusters-165"><a href="#by_vertex_clusters-165"><span class="linenos">165</span></a>    <span class="n">adj</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">cl_edge_lengths</span><span class="p">,</span>
</span><span id="by_vertex_clusters-166"><a href="#by_vertex_clusters-166"><span class="linenos">166</span></a>                                   <span class="p">(</span><span class="n">cl_edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cl_edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])),</span>
</span><span id="by_vertex_clusters-167"><a href="#by_vertex_clusters-167"><span class="linenos">167</span></a>                                  <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">))</span>
</span><span id="by_vertex_clusters-168"><a href="#by_vertex_clusters-168"><span class="linenos">168</span></a>
</span><span id="by_vertex_clusters-169"><a href="#by_vertex_clusters-169"><span class="linenos">169</span></a>    <span class="c1"># The cluster graph likely still contain cycles, let&#39;s get rid of them using</span>
</span><span id="by_vertex_clusters-170"><a href="#by_vertex_clusters-170"><span class="linenos">170</span></a>    <span class="c1"># a minimum spanning tree</span>
</span><span id="by_vertex_clusters-171"><a href="#by_vertex_clusters-171"><span class="linenos">171</span></a>    <span class="n">mst</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">minimum_spanning_tree</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span>
</span><span id="by_vertex_clusters-172"><a href="#by_vertex_clusters-172"><span class="linenos">172</span></a>                                                     <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="by_vertex_clusters-173"><a href="#by_vertex_clusters-173"><span class="linenos">173</span></a>
</span><span id="by_vertex_clusters-174"><a href="#by_vertex_clusters-174"><span class="linenos">174</span></a>    <span class="c1"># Turn into COO matrix</span>
</span><span id="by_vertex_clusters-175"><a href="#by_vertex_clusters-175"><span class="linenos">175</span></a>    <span class="n">coo</span> <span class="o">=</span> <span class="n">mst</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
</span><span id="by_vertex_clusters-176"><a href="#by_vertex_clusters-176"><span class="linenos">176</span></a>
</span><span id="by_vertex_clusters-177"><a href="#by_vertex_clusters-177"><span class="linenos">177</span></a>    <span class="c1"># Extract edge list</span>
</span><span id="by_vertex_clusters-178"><a href="#by_vertex_clusters-178"><span class="linenos">178</span></a>    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coo</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">coo</span><span class="o">.</span><span class="n">col</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
</span><span id="by_vertex_clusters-179"><a href="#by_vertex_clusters-179"><span class="linenos">179</span></a>
</span><span id="by_vertex_clusters-180"><a href="#by_vertex_clusters-180"><span class="linenos">180</span></a>    <span class="c1"># Produce final graph - this also takes care of some fixing</span>
</span><span id="by_vertex_clusters-181"><a href="#by_vertex_clusters-181"><span class="linenos">181</span></a>    <span class="n">G</span> <span class="o">=</span> <span class="n">edges_to_graph</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cl_edges</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span>
</span><span id="by_vertex_clusters-182"><a href="#by_vertex_clusters-182"><span class="linenos">182</span></a>                       <span class="n">drop_disconnected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fix_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="by_vertex_clusters-183"><a href="#by_vertex_clusters-183"><span class="linenos">183</span></a>
</span><span id="by_vertex_clusters-184"><a href="#by_vertex_clusters-184"><span class="linenos">184</span></a>    <span class="c1"># Generate a mesh vertex -&gt; skeleton vertex map</span>
</span><span id="by_vertex_clusters-185"><a href="#by_vertex_clusters-185"><span class="linenos">185</span></a>    <span class="c1"># Note that nodes are labeled by index of the cluster</span>
</span><span id="by_vertex_clusters-186"><a href="#by_vertex_clusters-186"><span class="linenos">186</span></a>    <span class="n">vertex_to_node_map</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">cl</span><span class="p">]</span>
</span><span id="by_vertex_clusters-187"><a href="#by_vertex_clusters-187"><span class="linenos">187</span></a>
</span><span id="by_vertex_clusters-188"><a href="#by_vertex_clusters-188"><span class="linenos">188</span></a>    <span class="c1"># Generate SWC</span>
</span><span id="by_vertex_clusters-189"><a href="#by_vertex_clusters-189"><span class="linenos">189</span></a>    <span class="n">swc</span><span class="p">,</span> <span class="n">new_ids</span> <span class="o">=</span> <span class="n">make_swc</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cl_coords</span><span class="p">,</span> <span class="n">reindex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="by_vertex_clusters-190"><a href="#by_vertex_clusters-190"><span class="linenos">190</span></a>
</span><span id="by_vertex_clusters-191"><a href="#by_vertex_clusters-191"><span class="linenos">191</span></a>    <span class="c1"># Update mesh map</span>
</span><span id="by_vertex_clusters-192"><a href="#by_vertex_clusters-192"><span class="linenos">192</span></a>    <span class="n">vertex_to_node_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_ids</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">vertex_to_node_map</span><span class="p">])</span>
</span><span id="by_vertex_clusters-193"><a href="#by_vertex_clusters-193"><span class="linenos">193</span></a>
</span><span id="by_vertex_clusters-194"><a href="#by_vertex_clusters-194"><span class="linenos">194</span></a>    <span class="k">return</span> <span class="n">Skeleton</span><span class="p">(</span><span class="n">swc</span><span class="o">=</span><span class="n">swc</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh_map</span><span class="o">=</span><span class="n">vertex_to_node_map</span><span class="p">,</span>
</span><span id="by_vertex_clusters-195"><a href="#by_vertex_clusters-195"><span class="linenos">195</span></a>                    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;vertex_clusters&#39;</span><span class="p">)</span>
</span></pre></div>


            <div class="docstring"><p>Skeletonize a (contracted) mesh by clustering vertices.</p>

<p>The algorithm traverses the mesh graph and groups vertices together that
are within a given distance to each other. This uses the geodesic
(along-the-mesh) distance, not simply the Euclidean distance. Subsequently
these groups of vertices are collapsed and re-connected respecting the
topology of the input mesh.</p>

<p>The graph traversal is fast and scales well, so this method is well suited
for meshes with lots of vertices. On the downside: this implementation is
not very clever and you might have to play around with the parameters
(mostly <code>sampling_dist</code>) to get decent results.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>mesh</strong> (mesh obj):
The mesh to be skeletonize. Can an object that has
<code>.vertices</code> and <code>.faces</code> properties  (e.g. a
trimesh.Trimesh) or a tuple <code>(vertices, faces)</code> or a
dictionary <code>{'vertices': vertices, 'faces': faces}</code>.</li>
<li><strong>sampling_dist</strong> (float | int):
Maximal distance at which vertices are clustered. This
parameter should be tuned based on the resolution of your
mesh (see Examples).</li>
<li><p><strong>cluster_pos</strong> ("median" | "center"):
How to determine the x/y/z coordinates of the collapsed
vertex clusters (i.e. the skeleton's nodes)::</p>

<ul>
<li>"median": Use the vertex closest to cluster's center of
mass.</li>
<li>"center": Use the center of mass. This makes for smoother
skeletons but can lead to nodes outside the mesh.</li>
</ul></li>
<li><strong>progress</strong> (bool):
If True, will show progress bar.</li>
</ul>

<h6 id="examples">Examples</h6>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">skeletor</span> <span class="k">as</span> <span class="nn">sk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">example_mesh</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cont</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">pre</span><span class="o">.</span><span class="n">contract</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeletonize</span><span class="o">.</span><span class="n">vertex_cluster</span><span class="p">(</span><span class="n">cont</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>
</code></pre>
</div>

<h6 id="returns">Returns</h6>

<ul>
<li><strong><a href="../skeletor.html#Skeleton">skeletor.Skeleton</a></strong>: Holds results of the skeletonization and enables quick
visualization.</li>
</ul>
</div>


                </section>
                <section id="by_edge_collapse">
                            <input id="by_edge_collapse-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">by_edge_collapse</span><span class="signature pdoc-code condensed">(<span class="param"><span class="n">mesh</span>, </span><span class="param"><span class="n">shape_weight</span><span class="o">=</span><span class="mi">1</span>, </span><span class="param"><span class="n">sample_weight</span><span class="o">=</span><span class="mf">0.1</span>, </span><span class="param"><span class="n">progress</span><span class="o">=</span><span class="kc">True</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="by_edge_collapse-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#by_edge_collapse"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="by_edge_collapse-38"><a href="#by_edge_collapse-38"><span class="linenos"> 38</span></a><span class="k">def</span> <span class="nf">by_edge_collapse</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">shape_weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="by_edge_collapse-39"><a href="#by_edge_collapse-39"><span class="linenos"> 39</span></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;Skeletonize a (contracted) mesh by iteratively collapsing edges.</span>
</span><span id="by_edge_collapse-40"><a href="#by_edge_collapse-40"><span class="linenos"> 40</span></a>
</span><span id="by_edge_collapse-41"><a href="#by_edge_collapse-41"><span class="linenos"> 41</span></a><span class="sd">    This algorithm (described in [1]) iteratively collapses edges that are part</span>
</span><span id="by_edge_collapse-42"><a href="#by_edge_collapse-42"><span class="linenos"> 42</span></a><span class="sd">    of a face until no more faces are left. Edges are chosen based on a cost</span>
</span><span id="by_edge_collapse-43"><a href="#by_edge_collapse-43"><span class="linenos"> 43</span></a><span class="sd">    function that penalizes collapses that would change the shape of the object</span>
</span><span id="by_edge_collapse-44"><a href="#by_edge_collapse-44"><span class="linenos"> 44</span></a><span class="sd">    or would introduce long edges.</span>
</span><span id="by_edge_collapse-45"><a href="#by_edge_collapse-45"><span class="linenos"> 45</span></a>
</span><span id="by_edge_collapse-46"><a href="#by_edge_collapse-46"><span class="linenos"> 46</span></a><span class="sd">    This is somewhat sensitive to the dimensions of the input mesh: too large</span>
</span><span id="by_edge_collapse-47"><a href="#by_edge_collapse-47"><span class="linenos"> 47</span></a><span class="sd">    and you might experience slow-downs or numpy OverflowErrors; too low and</span>
</span><span id="by_edge_collapse-48"><a href="#by_edge_collapse-48"><span class="linenos"> 48</span></a><span class="sd">    you might get skeletons that don&#39;t quite match the mesh (e.g. too few nodes).</span>
</span><span id="by_edge_collapse-49"><a href="#by_edge_collapse-49"><span class="linenos"> 49</span></a><span class="sd">    If you experience either, try down- or up-scaling your mesh, respectively.</span>
</span><span id="by_edge_collapse-50"><a href="#by_edge_collapse-50"><span class="linenos"> 50</span></a>
</span><span id="by_edge_collapse-51"><a href="#by_edge_collapse-51"><span class="linenos"> 51</span></a><span class="sd">    Parameters</span>
</span><span id="by_edge_collapse-52"><a href="#by_edge_collapse-52"><span class="linenos"> 52</span></a><span class="sd">    ----------</span>
</span><span id="by_edge_collapse-53"><a href="#by_edge_collapse-53"><span class="linenos"> 53</span></a><span class="sd">    mesh :          mesh obj</span>
</span><span id="by_edge_collapse-54"><a href="#by_edge_collapse-54"><span class="linenos"> 54</span></a><span class="sd">                    The mesh to be skeletonize. Can an object that has</span>
</span><span id="by_edge_collapse-55"><a href="#by_edge_collapse-55"><span class="linenos"> 55</span></a><span class="sd">                    ``.vertices`` and ``.faces`` properties  (e.g. a</span>
</span><span id="by_edge_collapse-56"><a href="#by_edge_collapse-56"><span class="linenos"> 56</span></a><span class="sd">                    trimesh.Trimesh) or a tuple ``(vertices, faces)`` or a</span>
</span><span id="by_edge_collapse-57"><a href="#by_edge_collapse-57"><span class="linenos"> 57</span></a><span class="sd">                    dictionary ``{&#39;vertices&#39;: vertices, &#39;faces&#39;: faces}``.</span>
</span><span id="by_edge_collapse-58"><a href="#by_edge_collapse-58"><span class="linenos"> 58</span></a><span class="sd">    shape_weight :  float, optional</span>
</span><span id="by_edge_collapse-59"><a href="#by_edge_collapse-59"><span class="linenos"> 59</span></a><span class="sd">                    Weight for shape costs which penalize collapsing edges that</span>
</span><span id="by_edge_collapse-60"><a href="#by_edge_collapse-60"><span class="linenos"> 60</span></a><span class="sd">                    would drastically change the shape of the object.</span>
</span><span id="by_edge_collapse-61"><a href="#by_edge_collapse-61"><span class="linenos"> 61</span></a><span class="sd">    sample_weight : float, optional</span>
</span><span id="by_edge_collapse-62"><a href="#by_edge_collapse-62"><span class="linenos"> 62</span></a><span class="sd">                    Weight for sampling costs which penalize collapses that</span>
</span><span id="by_edge_collapse-63"><a href="#by_edge_collapse-63"><span class="linenos"> 63</span></a><span class="sd">                    would generate prohibitively long edges.</span>
</span><span id="by_edge_collapse-64"><a href="#by_edge_collapse-64"><span class="linenos"> 64</span></a><span class="sd">    progress :      bool</span>
</span><span id="by_edge_collapse-65"><a href="#by_edge_collapse-65"><span class="linenos"> 65</span></a><span class="sd">                    If True, will show progress bar.</span>
</span><span id="by_edge_collapse-66"><a href="#by_edge_collapse-66"><span class="linenos"> 66</span></a>
</span><span id="by_edge_collapse-67"><a href="#by_edge_collapse-67"><span class="linenos"> 67</span></a><span class="sd">    Returns</span>
</span><span id="by_edge_collapse-68"><a href="#by_edge_collapse-68"><span class="linenos"> 68</span></a><span class="sd">    -------</span>
</span><span id="by_edge_collapse-69"><a href="#by_edge_collapse-69"><span class="linenos"> 69</span></a><span class="sd">    skeletor.Skeleton</span>
</span><span id="by_edge_collapse-70"><a href="#by_edge_collapse-70"><span class="linenos"> 70</span></a><span class="sd">                    Holds results of the skeletonization and enables quick</span>
</span><span id="by_edge_collapse-71"><a href="#by_edge_collapse-71"><span class="linenos"> 71</span></a><span class="sd">                    visualization.</span>
</span><span id="by_edge_collapse-72"><a href="#by_edge_collapse-72"><span class="linenos"> 72</span></a>
</span><span id="by_edge_collapse-73"><a href="#by_edge_collapse-73"><span class="linenos"> 73</span></a><span class="sd">    References</span>
</span><span id="by_edge_collapse-74"><a href="#by_edge_collapse-74"><span class="linenos"> 74</span></a><span class="sd">    ----------</span>
</span><span id="by_edge_collapse-75"><a href="#by_edge_collapse-75"><span class="linenos"> 75</span></a><span class="sd">    [1] Au OK, Tai CL, Chu HK, Cohen-Or D, Lee TY. Skeleton extraction by mesh</span>
</span><span id="by_edge_collapse-76"><a href="#by_edge_collapse-76"><span class="linenos"> 76</span></a><span class="sd">        contraction. ACM Transactions on Graphics (TOG). 2008 Aug 1;27(3):44.</span>
</span><span id="by_edge_collapse-77"><a href="#by_edge_collapse-77"><span class="linenos"> 77</span></a>
</span><span id="by_edge_collapse-78"><a href="#by_edge_collapse-78"><span class="linenos"> 78</span></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="by_edge_collapse-79"><a href="#by_edge_collapse-79"><span class="linenos"> 79</span></a>    <span class="n">mesh</span> <span class="o">=</span> <span class="n">make_trimesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="by_edge_collapse-80"><a href="#by_edge_collapse-80"><span class="linenos"> 80</span></a>
</span><span id="by_edge_collapse-81"><a href="#by_edge_collapse-81"><span class="linenos"> 81</span></a>    <span class="c1"># Shorthand faces and edges</span>
</span><span id="by_edge_collapse-82"><a href="#by_edge_collapse-82"><span class="linenos"> 82</span></a>    <span class="c1"># We convert to arrays to (a) make a copy and (b) remove potential overhead</span>
</span><span id="by_edge_collapse-83"><a href="#by_edge_collapse-83"><span class="linenos"> 83</span></a>    <span class="c1"># from these originally being trimesh TrackedArrays</span>
</span><span id="by_edge_collapse-84"><a href="#by_edge_collapse-84"><span class="linenos"> 84</span></a>    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">)</span>
</span><span id="by_edge_collapse-85"><a href="#by_edge_collapse-85"><span class="linenos"> 85</span></a>    <span class="n">verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
</span><span id="by_edge_collapse-86"><a href="#by_edge_collapse-86"><span class="linenos"> 86</span></a>
</span><span id="by_edge_collapse-87"><a href="#by_edge_collapse-87"><span class="linenos"> 87</span></a>    <span class="c1"># For cost calculations we will normalise coordinates</span>
</span><span id="by_edge_collapse-88"><a href="#by_edge_collapse-88"><span class="linenos"> 88</span></a>    <span class="c1"># This prevents getting ridiculuously large cost values ?e300</span>
</span><span id="by_edge_collapse-89"><a href="#by_edge_collapse-89"><span class="linenos"> 89</span></a>    <span class="c1"># verts = (verts - verts.min()) / (verts.max() - verts.min())</span>
</span><span id="by_edge_collapse-90"><a href="#by_edge_collapse-90"><span class="linenos"> 90</span></a>    <span class="n">edge_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">verts</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">verts</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</span><span id="by_edge_collapse-91"><a href="#by_edge_collapse-91"><span class="linenos"> 91</span></a>
</span><span id="by_edge_collapse-92"><a href="#by_edge_collapse-92"><span class="linenos"> 92</span></a>    <span class="c1"># Get a list of faces: [(edge1, edge2, edge3), ...]</span>
</span><span id="by_edge_collapse-93"><a href="#by_edge_collapse-93"><span class="linenos"> 93</span></a>    <span class="n">face_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces_unique_edges</span><span class="p">)</span>
</span><span id="by_edge_collapse-94"><a href="#by_edge_collapse-94"><span class="linenos"> 94</span></a>    <span class="c1"># Make sure these faces are unique, i.e. no [(e1, e2, e3), (e3, e2, e1)]</span>
</span><span id="by_edge_collapse-95"><a href="#by_edge_collapse-95"><span class="linenos"> 95</span></a>    <span class="n">face_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">face_edges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span><span id="by_edge_collapse-96"><a href="#by_edge_collapse-96"><span class="linenos"> 96</span></a>
</span><span id="by_edge_collapse-97"><a href="#by_edge_collapse-97"><span class="linenos"> 97</span></a>    <span class="c1"># Shape cost initialisation:</span>
</span><span id="by_edge_collapse-98"><a href="#by_edge_collapse-98"><span class="linenos"> 98</span></a>    <span class="c1"># Each vertex has a matrix Q which is used to determine the shape cost</span>
</span><span id="by_edge_collapse-99"><a href="#by_edge_collapse-99"><span class="linenos"> 99</span></a>    <span class="c1"># of collapsing each node. We need to generate a matrix (Q) for each</span>
</span><span id="by_edge_collapse-100"><a href="#by_edge_collapse-100"><span class="linenos">100</span></a>    <span class="c1"># vertex, then when we collapse two nodes, we can update using</span>
</span><span id="by_edge_collapse-101"><a href="#by_edge_collapse-101"><span class="linenos">101</span></a>    <span class="c1"># Qj &lt;- Qi + Qj, so the edges previously associated with vertex i</span>
</span><span id="by_edge_collapse-102"><a href="#by_edge_collapse-102"><span class="linenos">102</span></a>    <span class="c1"># are now associated with vertex j.</span>
</span><span id="by_edge_collapse-103"><a href="#by_edge_collapse-103"><span class="linenos">103</span></a>
</span><span id="by_edge_collapse-104"><a href="#by_edge_collapse-104"><span class="linenos">104</span></a>    <span class="c1"># For each edge, generate a matrix (K). K is made up of two sets of</span>
</span><span id="by_edge_collapse-105"><a href="#by_edge_collapse-105"><span class="linenos">105</span></a>    <span class="c1"># coordinates in 3D space, a and b. a is the normalised edge vector</span>
</span><span id="by_edge_collapse-106"><a href="#by_edge_collapse-106"><span class="linenos">106</span></a>    <span class="c1"># of edge(i,j) and b = a * &lt;x/y/z coordinates of vertex i&gt;</span>
</span><span id="by_edge_collapse-107"><a href="#by_edge_collapse-107"><span class="linenos">107</span></a>    <span class="c1">#</span>
</span><span id="by_edge_collapse-108"><a href="#by_edge_collapse-108"><span class="linenos">108</span></a>    <span class="c1"># The matrix K takes the form:</span>
</span><span id="by_edge_collapse-109"><a href="#by_edge_collapse-109"><span class="linenos">109</span></a>    <span class="c1">#</span>
</span><span id="by_edge_collapse-110"><a href="#by_edge_collapse-110"><span class="linenos">110</span></a>    <span class="c1">#        Kij = 0, -az, ay, -bx</span>
</span><span id="by_edge_collapse-111"><a href="#by_edge_collapse-111"><span class="linenos">111</span></a>    <span class="c1">#              az, 0, -ax, -by</span>
</span><span id="by_edge_collapse-112"><a href="#by_edge_collapse-112"><span class="linenos">112</span></a>    <span class="c1">#             -ay, ax, 0,  -bz</span>
</span><span id="by_edge_collapse-113"><a href="#by_edge_collapse-113"><span class="linenos">113</span></a>
</span><span id="by_edge_collapse-114"><a href="#by_edge_collapse-114"><span class="linenos">114</span></a>    <span class="n">edge_co0</span><span class="p">,</span> <span class="n">edge_co1</span> <span class="o">=</span> <span class="n">verts</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">verts</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
</span><span id="by_edge_collapse-115"><a href="#by_edge_collapse-115"><span class="linenos">115</span></a>    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge_co1</span> <span class="o">-</span> <span class="n">edge_co0</span><span class="p">)</span> <span class="o">/</span> <span class="n">edge_lengths</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="by_edge_collapse-116"><a href="#by_edge_collapse-116"><span class="linenos">116</span></a>    <span class="c1"># Note: It&#39;s a bit unclear to me whether the normalised edge vector should</span>
</span><span id="by_edge_collapse-117"><a href="#by_edge_collapse-117"><span class="linenos">117</span></a>    <span class="c1"># be allowed to have negative values but I seem to be getting better</span>
</span><span id="by_edge_collapse-118"><a href="#by_edge_collapse-118"><span class="linenos">118</span></a>    <span class="c1"># results if I use absolute values</span>
</span><span id="by_edge_collapse-119"><a href="#by_edge_collapse-119"><span class="linenos">119</span></a>    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span id="by_edge_collapse-120"><a href="#by_edge_collapse-120"><span class="linenos">120</span></a>    <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">edge_co0</span>
</span><span id="by_edge_collapse-121"><a href="#by_edge_collapse-121"><span class="linenos">121</span></a>
</span><span id="by_edge_collapse-122"><a href="#by_edge_collapse-122"><span class="linenos">122</span></a>    <span class="c1"># Bunch of zeros</span>
</span><span id="by_edge_collapse-123"><a href="#by_edge_collapse-123"><span class="linenos">123</span></a>    <span class="n">zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span><span id="by_edge_collapse-124"><a href="#by_edge_collapse-124"><span class="linenos">124</span></a>
</span><span id="by_edge_collapse-125"><a href="#by_edge_collapse-125"><span class="linenos">125</span></a>    <span class="c1"># Generate matrix K</span>
</span><span id="by_edge_collapse-126"><a href="#by_edge_collapse-126"><span class="linenos">126</span></a>    <span class="n">K</span> <span class="o">=</span> <span class="p">[[</span><span class="n">zero</span><span class="p">,</span>    <span class="o">-</span><span class="n">a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>    <span class="o">-</span><span class="n">b</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]],</span>
</span><span id="by_edge_collapse-127"><a href="#by_edge_collapse-127"><span class="linenos">127</span></a>         <span class="p">[</span><span class="n">a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>  <span class="n">zero</span><span class="p">,</span>    <span class="o">-</span><span class="n">a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>   <span class="o">-</span><span class="n">b</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]],</span>
</span><span id="by_edge_collapse-128"><a href="#by_edge_collapse-128"><span class="linenos">128</span></a>         <span class="p">[</span><span class="o">-</span><span class="n">a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">zero</span><span class="p">,</span>       <span class="o">-</span><span class="n">b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]]]</span>
</span><span id="by_edge_collapse-129"><a href="#by_edge_collapse-129"><span class="linenos">129</span></a>    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
</span><span id="by_edge_collapse-130"><a href="#by_edge_collapse-130"><span class="linenos">130</span></a>
</span><span id="by_edge_collapse-131"><a href="#by_edge_collapse-131"><span class="linenos">131</span></a>    <span class="c1"># Q for vertex i is then the sum of the products of (kT,k) for ALL edges</span>
</span><span id="by_edge_collapse-132"><a href="#by_edge_collapse-132"><span class="linenos">132</span></a>    <span class="c1"># connected to vertex i:</span>
</span><span id="by_edge_collapse-133"><a href="#by_edge_collapse-133"><span class="linenos">133</span></a>    <span class="c1"># Initialize matrix of correct shape</span>
</span><span id="by_edge_collapse-134"><a href="#by_edge_collapse-134"><span class="linenos">134</span></a>    <span class="n">Q_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">verts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
</span><span id="by_edge_collapse-135"><a href="#by_edge_collapse-135"><span class="linenos">135</span></a>
</span><span id="by_edge_collapse-136"><a href="#by_edge_collapse-136"><span class="linenos">136</span></a>    <span class="c1"># Generate (kT, K)</span>
</span><span id="by_edge_collapse-137"><a href="#by_edge_collapse-137"><span class="linenos">137</span></a>    <span class="n">kT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</span><span id="by_edge_collapse-138"><a href="#by_edge_collapse-138"><span class="linenos">138</span></a>
</span><span id="by_edge_collapse-139"><a href="#by_edge_collapse-139"><span class="linenos">139</span></a>    <span class="c1"># To get the sum of the products in the correct format we have to</span>
</span><span id="by_edge_collapse-140"><a href="#by_edge_collapse-140"><span class="linenos">140</span></a>    <span class="c1"># do some annoying transposes to get to (4, 4, len(edges))</span>
</span><span id="by_edge_collapse-141"><a href="#by_edge_collapse-141"><span class="linenos">141</span></a>    <span class="n">K_dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">kT</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
</span><span id="by_edge_collapse-142"><a href="#by_edge_collapse-142"><span class="linenos">142</span></a>
</span><span id="by_edge_collapse-143"><a href="#by_edge_collapse-143"><span class="linenos">143</span></a>    <span class="c1"># Iterate over all vertices</span>
</span><span id="by_edge_collapse-144"><a href="#by_edge_collapse-144"><span class="linenos">144</span></a>    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)):</span>
</span><span id="by_edge_collapse-145"><a href="#by_edge_collapse-145"><span class="linenos">145</span></a>        <span class="c1"># Find edges that contain this vertex</span>
</span><span id="by_edge_collapse-146"><a href="#by_edge_collapse-146"><span class="linenos">146</span></a>        <span class="n">cond1</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span>
</span><span id="by_edge_collapse-147"><a href="#by_edge_collapse-147"><span class="linenos">147</span></a>        <span class="n">cond2</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span>
</span><span id="by_edge_collapse-148"><a href="#by_edge_collapse-148"><span class="linenos">148</span></a>        <span class="c1"># Note that this does not take directionality of edges into account</span>
</span><span id="by_edge_collapse-149"><a href="#by_edge_collapse-149"><span class="linenos">149</span></a>        <span class="c1"># Not sure if that&#39;s intended?</span>
</span><span id="by_edge_collapse-150"><a href="#by_edge_collapse-150"><span class="linenos">150</span></a>
</span><span id="by_edge_collapse-151"><a href="#by_edge_collapse-151"><span class="linenos">151</span></a>        <span class="c1"># Get indices of these edges</span>
</span><span id="by_edge_collapse-152"><a href="#by_edge_collapse-152"><span class="linenos">152</span></a>        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cond1</span> <span class="o">|</span> <span class="n">cond2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="by_edge_collapse-153"><a href="#by_edge_collapse-153"><span class="linenos">153</span></a>
</span><span id="by_edge_collapse-154"><a href="#by_edge_collapse-154"><span class="linenos">154</span></a>        <span class="c1"># Get the products for all edges adjacent to mesh</span>
</span><span id="by_edge_collapse-155"><a href="#by_edge_collapse-155"><span class="linenos">155</span></a>        <span class="n">Q</span> <span class="o">=</span> <span class="n">K_dot</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">indices</span><span class="p">]</span>
</span><span id="by_edge_collapse-156"><a href="#by_edge_collapse-156"><span class="linenos">156</span></a>        <span class="c1"># Sum over all edges</span>
</span><span id="by_edge_collapse-157"><a href="#by_edge_collapse-157"><span class="linenos">157</span></a>        <span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</span><span id="by_edge_collapse-158"><a href="#by_edge_collapse-158"><span class="linenos">158</span></a>        <span class="c1"># Add to Q array</span>
</span><span id="by_edge_collapse-159"><a href="#by_edge_collapse-159"><span class="linenos">159</span></a>        <span class="n">Q_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q</span>
</span><span id="by_edge_collapse-160"><a href="#by_edge_collapse-160"><span class="linenos">160</span></a>
</span><span id="by_edge_collapse-161"><a href="#by_edge_collapse-161"><span class="linenos">161</span></a>    <span class="c1"># Not sure if we are doing something wrong when calculating the Q array but</span>
</span><span id="by_edge_collapse-162"><a href="#by_edge_collapse-162"><span class="linenos">162</span></a>    <span class="c1"># we end up having negative values which translate into negative scores.</span>
</span><span id="by_edge_collapse-163"><a href="#by_edge_collapse-163"><span class="linenos">163</span></a>    <span class="c1"># This in turn is bad because we propagate that negative score when</span>
</span><span id="by_edge_collapse-164"><a href="#by_edge_collapse-164"><span class="linenos">164</span></a>    <span class="c1"># collapsing edges which leads to a &quot;zipper-effect&quot; where nodes collapse</span>
</span><span id="by_edge_collapse-165"><a href="#by_edge_collapse-165"><span class="linenos">165</span></a>    <span class="c1"># in sequence a-&gt;b-&gt;c-&gt;d until they hit some node with really high cost</span>
</span><span id="by_edge_collapse-166"><a href="#by_edge_collapse-166"><span class="linenos">166</span></a>    <span class="c1"># Q_array -= Q_array.min()</span>
</span><span id="by_edge_collapse-167"><a href="#by_edge_collapse-167"><span class="linenos">167</span></a>
</span><span id="by_edge_collapse-168"><a href="#by_edge_collapse-168"><span class="linenos">168</span></a>    <span class="c1"># Edge collapse:</span>
</span><span id="by_edge_collapse-169"><a href="#by_edge_collapse-169"><span class="linenos">169</span></a>    <span class="c1"># Determining which edge to collapse is a weighted sum of the shape and</span>
</span><span id="by_edge_collapse-170"><a href="#by_edge_collapse-170"><span class="linenos">170</span></a>    <span class="c1"># sampling cost. The shape cost of vertex i is Fa(p) = pT Qi p where p is</span>
</span><span id="by_edge_collapse-171"><a href="#by_edge_collapse-171"><span class="linenos">171</span></a>    <span class="c1"># the coordinates of point p (vertex i here) in homogeneous representation.</span>
</span><span id="by_edge_collapse-172"><a href="#by_edge_collapse-172"><span class="linenos">172</span></a>    <span class="c1"># The variable w from above is the value for the homogeneous 4th dimension.</span>
</span><span id="by_edge_collapse-173"><a href="#by_edge_collapse-173"><span class="linenos">173</span></a>    <span class="c1"># T denotes transpose of matrix.</span>
</span><span id="by_edge_collapse-174"><a href="#by_edge_collapse-174"><span class="linenos">174</span></a>    <span class="c1"># The shape cost of collapsing the edge Fa(i,j) = Fi(vj) + Fj(vj).</span>
</span><span id="by_edge_collapse-175"><a href="#by_edge_collapse-175"><span class="linenos">175</span></a>    <span class="c1"># vi and vj being the coordinates of the vertex in homogeneous representation</span>
</span><span id="by_edge_collapse-176"><a href="#by_edge_collapse-176"><span class="linenos">176</span></a>    <span class="c1"># (p in equation before)</span>
</span><span id="by_edge_collapse-177"><a href="#by_edge_collapse-177"><span class="linenos">177</span></a>    <span class="c1"># The sampling cost penalises edge collapses that generate overly long edges,</span>
</span><span id="by_edge_collapse-178"><a href="#by_edge_collapse-178"><span class="linenos">178</span></a>    <span class="c1"># based on the distance traveled by all edges to vi, when vi is merged with</span>
</span><span id="by_edge_collapse-179"><a href="#by_edge_collapse-179"><span class="linenos">179</span></a>    <span class="c1"># vj. (Eq. 7 in paper)</span>
</span><span id="by_edge_collapse-180"><a href="#by_edge_collapse-180"><span class="linenos">180</span></a>    <span class="c1"># You cannot collapse an edge (i -&gt; j) if k is a common adjacent vertex of</span>
</span><span id="by_edge_collapse-181"><a href="#by_edge_collapse-181"><span class="linenos">181</span></a>    <span class="c1"># both i and j, but (i/j/k) is not a face.</span>
</span><span id="by_edge_collapse-182"><a href="#by_edge_collapse-182"><span class="linenos">182</span></a>    <span class="c1"># We will set the cost of these edges to infinity.</span>
</span><span id="by_edge_collapse-183"><a href="#by_edge_collapse-183"><span class="linenos">183</span></a>
</span><span id="by_edge_collapse-184"><a href="#by_edge_collapse-184"><span class="linenos">184</span></a>    <span class="c1"># Now work out the shape cost of collapsing each node (eq. 7)</span>
</span><span id="by_edge_collapse-185"><a href="#by_edge_collapse-185"><span class="linenos">185</span></a>    <span class="c1"># First get coordinates of the first node of each edge</span>
</span><span id="by_edge_collapse-186"><a href="#by_edge_collapse-186"><span class="linenos">186</span></a>    <span class="c1"># Note that in Nik&#39;s implementation this was the second node</span>
</span><span id="by_edge_collapse-187"><a href="#by_edge_collapse-187"><span class="linenos">187</span></a>    <span class="n">p</span> <span class="o">=</span> <span class="n">verts</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
</span><span id="by_edge_collapse-188"><a href="#by_edge_collapse-188"><span class="linenos">188</span></a>
</span><span id="by_edge_collapse-189"><a href="#by_edge_collapse-189"><span class="linenos">189</span></a>    <span class="c1"># Append weight factor</span>
</span><span id="by_edge_collapse-190"><a href="#by_edge_collapse-190"><span class="linenos">190</span></a>    <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span>
</span><span id="by_edge_collapse-191"><a href="#by_edge_collapse-191"><span class="linenos">191</span></a>    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">w</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span><span id="by_edge_collapse-192"><a href="#by_edge_collapse-192"><span class="linenos">192</span></a>
</span><span id="by_edge_collapse-193"><a href="#by_edge_collapse-193"><span class="linenos">193</span></a>    <span class="n">this_Q1</span> <span class="o">=</span> <span class="n">Q_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
</span><span id="by_edge_collapse-194"><a href="#by_edge_collapse-194"><span class="linenos">194</span></a>    <span class="n">this_Q2</span> <span class="o">=</span> <span class="n">Q_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
</span><span id="by_edge_collapse-195"><a href="#by_edge_collapse-195"><span class="linenos">195</span></a>
</span><span id="by_edge_collapse-196"><a href="#by_edge_collapse-196"><span class="linenos">196</span></a>    <span class="n">F1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,kji-&gt;ij&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">this_Q1</span><span class="p">)[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
</span><span id="by_edge_collapse-197"><a href="#by_edge_collapse-197"><span class="linenos">197</span></a>    <span class="n">F2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,kji-&gt;ij&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">this_Q2</span><span class="p">)[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
</span><span id="by_edge_collapse-198"><a href="#by_edge_collapse-198"><span class="linenos">198</span></a>
</span><span id="by_edge_collapse-199"><a href="#by_edge_collapse-199"><span class="linenos">199</span></a>    <span class="c1"># Calculate and append shape cost</span>
</span><span id="by_edge_collapse-200"><a href="#by_edge_collapse-200"><span class="linenos">200</span></a>    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span><span id="by_edge_collapse-201"><a href="#by_edge_collapse-201"><span class="linenos">201</span></a>    <span class="n">shape_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span><span id="by_edge_collapse-202"><a href="#by_edge_collapse-202"><span class="linenos">202</span></a>
</span><span id="by_edge_collapse-203"><a href="#by_edge_collapse-203"><span class="linenos">203</span></a>    <span class="c1"># Sum lengths of all edges associated with a given vertex</span>
</span><span id="by_edge_collapse-204"><a href="#by_edge_collapse-204"><span class="linenos">204</span></a>    <span class="c1"># This is easiest by generating a sparse matrix from the edges</span>
</span><span id="by_edge_collapse-205"><a href="#by_edge_collapse-205"><span class="linenos">205</span></a>    <span class="c1"># and then summing by row</span>
</span><span id="by_edge_collapse-206"><a href="#by_edge_collapse-206"><span class="linenos">206</span></a>    <span class="n">adj</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">edge_lengths</span><span class="p">,</span>
</span><span id="by_edge_collapse-207"><a href="#by_edge_collapse-207"><span class="linenos">207</span></a>                                   <span class="p">(</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])),</span>
</span><span id="by_edge_collapse-208"><a href="#by_edge_collapse-208"><span class="linenos">208</span></a>                                  <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">verts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">verts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</span><span id="by_edge_collapse-209"><a href="#by_edge_collapse-209"><span class="linenos">209</span></a>
</span><span id="by_edge_collapse-210"><a href="#by_edge_collapse-210"><span class="linenos">210</span></a>    <span class="c1"># This makes sure the matrix is symmetrical, i.e. a-&gt;b == a&lt;-b</span>
</span><span id="by_edge_collapse-211"><a href="#by_edge_collapse-211"><span class="linenos">211</span></a>    <span class="c1"># Note that I&#39;m not sure whether this is strictly necessary but it really</span>
</span><span id="by_edge_collapse-212"><a href="#by_edge_collapse-212"><span class="linenos">212</span></a>    <span class="c1"># can&#39;t hurt</span>
</span><span id="by_edge_collapse-213"><a href="#by_edge_collapse-213"><span class="linenos">213</span></a>    <span class="n">adj</span> <span class="o">=</span> <span class="n">adj</span> <span class="o">+</span> <span class="n">adj</span><span class="o">.</span><span class="n">T</span>
</span><span id="by_edge_collapse-214"><a href="#by_edge_collapse-214"><span class="linenos">214</span></a>
</span><span id="by_edge_collapse-215"><a href="#by_edge_collapse-215"><span class="linenos">215</span></a>    <span class="c1"># Get the lengths associated with each vertex</span>
</span><span id="by_edge_collapse-216"><a href="#by_edge_collapse-216"><span class="linenos">216</span></a>    <span class="n">verts_lengths</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span><span id="by_edge_collapse-217"><a href="#by_edge_collapse-217"><span class="linenos">217</span></a>
</span><span id="by_edge_collapse-218"><a href="#by_edge_collapse-218"><span class="linenos">218</span></a>    <span class="c1"># We need to flatten this (something funny with summing sparse matrices)</span>
</span><span id="by_edge_collapse-219"><a href="#by_edge_collapse-219"><span class="linenos">219</span></a>    <span class="n">verts_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">verts_lengths</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
</span><span id="by_edge_collapse-220"><a href="#by_edge_collapse-220"><span class="linenos">220</span></a>
</span><span id="by_edge_collapse-221"><a href="#by_edge_collapse-221"><span class="linenos">221</span></a>    <span class="c1"># Map the sum of vertex lengths onto edges (as per first vertex in edge)</span>
</span><span id="by_edge_collapse-222"><a href="#by_edge_collapse-222"><span class="linenos">222</span></a>    <span class="n">ik_edge</span> <span class="o">=</span> <span class="n">verts_lengths</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
</span><span id="by_edge_collapse-223"><a href="#by_edge_collapse-223"><span class="linenos">223</span></a>
</span><span id="by_edge_collapse-224"><a href="#by_edge_collapse-224"><span class="linenos">224</span></a>    <span class="c1"># Calculate sampling cost</span>
</span><span id="by_edge_collapse-225"><a href="#by_edge_collapse-225"><span class="linenos">225</span></a>    <span class="n">sample_cost</span> <span class="o">=</span> <span class="n">edge_lengths</span> <span class="o">*</span> <span class="p">(</span><span class="n">ik_edge</span> <span class="o">-</span> <span class="n">edge_lengths</span><span class="p">)</span>
</span><span id="by_edge_collapse-226"><a href="#by_edge_collapse-226"><span class="linenos">226</span></a>
</span><span id="by_edge_collapse-227"><a href="#by_edge_collapse-227"><span class="linenos">227</span></a>    <span class="c1"># Determine which edge to collapse and collapse it</span>
</span><span id="by_edge_collapse-228"><a href="#by_edge_collapse-228"><span class="linenos">228</span></a>    <span class="c1"># Total Cost - weighted sum of shape and sample cost, equation 8 in paper</span>
</span><span id="by_edge_collapse-229"><a href="#by_edge_collapse-229"><span class="linenos">229</span></a>    <span class="n">F_T</span> <span class="o">=</span> <span class="n">shape_cost</span> <span class="o">*</span> <span class="n">shape_weight</span> <span class="o">+</span> <span class="n">sample_cost</span> <span class="o">*</span> <span class="n">sample_weight</span>
</span><span id="by_edge_collapse-230"><a href="#by_edge_collapse-230"><span class="linenos">230</span></a>
</span><span id="by_edge_collapse-231"><a href="#by_edge_collapse-231"><span class="linenos">231</span></a>    <span class="c1"># Now start collapsing edges one at a time</span>
</span><span id="by_edge_collapse-232"><a href="#by_edge_collapse-232"><span class="linenos">232</span></a>    <span class="n">face_count</span> <span class="o">=</span> <span class="n">face_edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># keep track of face counts for progress bar</span>
</span><span id="by_edge_collapse-233"><a href="#by_edge_collapse-233"><span class="linenos">233</span></a>    <span class="n">is_collapsed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
</span><span id="by_edge_collapse-234"><a href="#by_edge_collapse-234"><span class="linenos">234</span></a>    <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
</span><span id="by_edge_collapse-235"><a href="#by_edge_collapse-235"><span class="linenos">235</span></a>    <span class="k">with</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Collapsing edges&#39;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="n">face_count</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">progress</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
</span><span id="by_edge_collapse-236"><a href="#by_edge_collapse-236"><span class="linenos">236</span></a>        <span class="k">while</span> <span class="n">face_edges</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
</span><span id="by_edge_collapse-237"><a href="#by_edge_collapse-237"><span class="linenos">237</span></a>            <span class="c1"># Uncomment to get a more-or-less random edge collapse</span>
</span><span id="by_edge_collapse-238"><a href="#by_edge_collapse-238"><span class="linenos">238</span></a>            <span class="c1"># F_T[:] = 0</span>
</span><span id="by_edge_collapse-239"><a href="#by_edge_collapse-239"><span class="linenos">239</span></a>
</span><span id="by_edge_collapse-240"><a href="#by_edge_collapse-240"><span class="linenos">240</span></a>            <span class="c1"># Update progress bar</span>
</span><span id="by_edge_collapse-241"><a href="#by_edge_collapse-241"><span class="linenos">241</span></a>            <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">face_count</span> <span class="o">-</span> <span class="n">face_edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span><span id="by_edge_collapse-242"><a href="#by_edge_collapse-242"><span class="linenos">242</span></a>            <span class="n">face_count</span> <span class="o">=</span> <span class="n">face_edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="by_edge_collapse-243"><a href="#by_edge_collapse-243"><span class="linenos">243</span></a>
</span><span id="by_edge_collapse-244"><a href="#by_edge_collapse-244"><span class="linenos">244</span></a>            <span class="c1"># This has to come at the beginning of the loop</span>
</span><span id="by_edge_collapse-245"><a href="#by_edge_collapse-245"><span class="linenos">245</span></a>            <span class="c1"># Set cost of collapsing edges without faces to infinite</span>
</span><span id="by_edge_collapse-246"><a href="#by_edge_collapse-246"><span class="linenos">246</span></a>            <span class="n">F_T</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
</span><span id="by_edge_collapse-247"><a href="#by_edge_collapse-247"><span class="linenos">247</span></a>            <span class="n">F_T</span><span class="p">[</span><span class="n">is_collapsed</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
</span><span id="by_edge_collapse-248"><a href="#by_edge_collapse-248"><span class="linenos">248</span></a>
</span><span id="by_edge_collapse-249"><a href="#by_edge_collapse-249"><span class="linenos">249</span></a>            <span class="c1"># Get the edge that we want to collapse</span>
</span><span id="by_edge_collapse-250"><a href="#by_edge_collapse-250"><span class="linenos">250</span></a>            <span class="n">collapse_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">F_T</span><span class="p">)</span>
</span><span id="by_edge_collapse-251"><a href="#by_edge_collapse-251"><span class="linenos">251</span></a>            <span class="c1"># Get the vertices this edge connects</span>
</span><span id="by_edge_collapse-252"><a href="#by_edge_collapse-252"><span class="linenos">252</span></a>            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">collapse_ix</span><span class="p">]</span>
</span><span id="by_edge_collapse-253"><a href="#by_edge_collapse-253"><span class="linenos">253</span></a>            <span class="c1"># Get all edges that contain these vertices:</span>
</span><span id="by_edge_collapse-254"><a href="#by_edge_collapse-254"><span class="linenos">254</span></a>            <span class="c1"># First, edges that are (uv, x)</span>
</span><span id="by_edge_collapse-255"><a href="#by_edge_collapse-255"><span class="linenos">255</span></a>            <span class="n">connects_uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">])</span>
</span><span id="by_edge_collapse-256"><a href="#by_edge_collapse-256"><span class="linenos">256</span></a>            <span class="c1"># Second, check if any (uv, x) edges are (uv, uv)</span>
</span><span id="by_edge_collapse-257"><a href="#by_edge_collapse-257"><span class="linenos">257</span></a>            <span class="n">connects_uv</span><span class="p">[</span><span class="n">connects_uv</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">connects_uv</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">])</span>
</span><span id="by_edge_collapse-258"><a href="#by_edge_collapse-258"><span class="linenos">258</span></a>
</span><span id="by_edge_collapse-259"><a href="#by_edge_collapse-259"><span class="linenos">259</span></a>            <span class="c1"># Remove uu and vv edges</span>
</span><span id="by_edge_collapse-260"><a href="#by_edge_collapse-260"><span class="linenos">260</span></a>            <span class="n">uuvv</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
</span><span id="by_edge_collapse-261"><a href="#by_edge_collapse-261"><span class="linenos">261</span></a>            <span class="n">connects_uv</span> <span class="o">=</span> <span class="n">connects_uv</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">uuvv</span>
</span><span id="by_edge_collapse-262"><a href="#by_edge_collapse-262"><span class="linenos">262</span></a>            <span class="c1"># Get the edge&#39;s indices</span>
</span><span id="by_edge_collapse-263"><a href="#by_edge_collapse-263"><span class="linenos">263</span></a>            <span class="n">clps_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">connects_uv</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="by_edge_collapse-264"><a href="#by_edge_collapse-264"><span class="linenos">264</span></a>
</span><span id="by_edge_collapse-265"><a href="#by_edge_collapse-265"><span class="linenos">265</span></a>            <span class="c1"># Now find find the faces the collapsed edge is part of</span>
</span><span id="by_edge_collapse-266"><a href="#by_edge_collapse-266"><span class="linenos">266</span></a>            <span class="c1"># Note: splitting this into three conditions is marginally faster than</span>
</span><span id="by_edge_collapse-267"><a href="#by_edge_collapse-267"><span class="linenos">267</span></a>            <span class="c1"># np.any(np.isin(face_edges, clps_edges), axis=1)</span>
</span><span id="by_edge_collapse-268"><a href="#by_edge_collapse-268"><span class="linenos">268</span></a>            <span class="n">uv0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">face_edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">clps_edges</span><span class="p">)</span>
</span><span id="by_edge_collapse-269"><a href="#by_edge_collapse-269"><span class="linenos">269</span></a>            <span class="n">uv1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">face_edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">clps_edges</span><span class="p">)</span>
</span><span id="by_edge_collapse-270"><a href="#by_edge_collapse-270"><span class="linenos">270</span></a>            <span class="n">uv2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">face_edges</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">clps_edges</span><span class="p">)</span>
</span><span id="by_edge_collapse-271"><a href="#by_edge_collapse-271"><span class="linenos">271</span></a>            <span class="n">has_uv</span> <span class="o">=</span> <span class="n">uv0</span> <span class="o">|</span> <span class="n">uv1</span> <span class="o">|</span> <span class="n">uv2</span>
</span><span id="by_edge_collapse-272"><a href="#by_edge_collapse-272"><span class="linenos">272</span></a>
</span><span id="by_edge_collapse-273"><a href="#by_edge_collapse-273"><span class="linenos">273</span></a>            <span class="c1"># If these edges do not have adjacent faces anymore</span>
</span><span id="by_edge_collapse-274"><a href="#by_edge_collapse-274"><span class="linenos">274</span></a>            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">has_uv</span><span class="p">):</span>
</span><span id="by_edge_collapse-275"><a href="#by_edge_collapse-275"><span class="linenos">275</span></a>                <span class="c1"># Track this edge as a keeper</span>
</span><span id="by_edge_collapse-276"><a href="#by_edge_collapse-276"><span class="linenos">276</span></a>                <span class="n">keep</span><span class="p">[</span><span class="n">clps_edges</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="by_edge_collapse-277"><a href="#by_edge_collapse-277"><span class="linenos">277</span></a>                <span class="k">continue</span>
</span><span id="by_edge_collapse-278"><a href="#by_edge_collapse-278"><span class="linenos">278</span></a>
</span><span id="by_edge_collapse-279"><a href="#by_edge_collapse-279"><span class="linenos">279</span></a>            <span class="c1"># Get the collapsed faces [(e1, e2, e3), ...] for this edge</span>
</span><span id="by_edge_collapse-280"><a href="#by_edge_collapse-280"><span class="linenos">280</span></a>            <span class="n">clps_faces</span> <span class="o">=</span> <span class="n">face_edges</span><span class="p">[</span><span class="n">has_uv</span><span class="p">]</span>
</span><span id="by_edge_collapse-281"><a href="#by_edge_collapse-281"><span class="linenos">281</span></a>
</span><span id="by_edge_collapse-282"><a href="#by_edge_collapse-282"><span class="linenos">282</span></a>            <span class="c1"># Remove the collapsed faces</span>
</span><span id="by_edge_collapse-283"><a href="#by_edge_collapse-283"><span class="linenos">283</span></a>            <span class="n">face_edges</span> <span class="o">=</span> <span class="n">face_edges</span><span class="p">[</span><span class="o">~</span><span class="n">has_uv</span><span class="p">]</span>
</span><span id="by_edge_collapse-284"><a href="#by_edge_collapse-284"><span class="linenos">284</span></a>
</span><span id="by_edge_collapse-285"><a href="#by_edge_collapse-285"><span class="linenos">285</span></a>            <span class="c1"># Track these edges as collapsed</span>
</span><span id="by_edge_collapse-286"><a href="#by_edge_collapse-286"><span class="linenos">286</span></a>            <span class="n">is_collapsed</span><span class="p">[</span><span class="n">clps_edges</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="by_edge_collapse-287"><a href="#by_edge_collapse-287"><span class="linenos">287</span></a>
</span><span id="by_edge_collapse-288"><a href="#by_edge_collapse-288"><span class="linenos">288</span></a>            <span class="c1"># Get the adjacent edges (i.e. non-uv edges)</span>
</span><span id="by_edge_collapse-289"><a href="#by_edge_collapse-289"><span class="linenos">289</span></a>            <span class="n">adj_edges</span> <span class="o">=</span> <span class="n">clps_faces</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">clps_faces</span><span class="p">,</span> <span class="n">clps_edges</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">clps_faces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
</span><span id="by_edge_collapse-290"><a href="#by_edge_collapse-290"><span class="linenos">290</span></a>
</span><span id="by_edge_collapse-291"><a href="#by_edge_collapse-291"><span class="linenos">291</span></a>            <span class="c1"># We have to do some sorting and finding unique edges to make sure</span>
</span><span id="by_edge_collapse-292"><a href="#by_edge_collapse-292"><span class="linenos">292</span></a>            <span class="c1"># remapping is done correctly further down</span>
</span><span id="by_edge_collapse-293"><a href="#by_edge_collapse-293"><span class="linenos">293</span></a>            <span class="c1"># NOTE: Not sure we really need this, so leaving it out for now</span>
</span><span id="by_edge_collapse-294"><a href="#by_edge_collapse-294"><span class="linenos">294</span></a>            <span class="c1"># adj_edges = np.unique(np.sort(adj_edges, axis=1), axis=0)</span>
</span><span id="by_edge_collapse-295"><a href="#by_edge_collapse-295"><span class="linenos">295</span></a>
</span><span id="by_edge_collapse-296"><a href="#by_edge_collapse-296"><span class="linenos">296</span></a>            <span class="c1"># We need to keep track of changes to the adjacent faces</span>
</span><span id="by_edge_collapse-297"><a href="#by_edge_collapse-297"><span class="linenos">297</span></a>            <span class="c1"># Basically each face in (i, j, k) will be reduced to one edge</span>
</span><span id="by_edge_collapse-298"><a href="#by_edge_collapse-298"><span class="linenos">298</span></a>            <span class="c1"># which points from u -&gt; v</span>
</span><span id="by_edge_collapse-299"><a href="#by_edge_collapse-299"><span class="linenos">299</span></a>            <span class="c1"># -&gt; replace occurrences of loosing edge with winning edge</span>
</span><span id="by_edge_collapse-300"><a href="#by_edge_collapse-300"><span class="linenos">300</span></a>            <span class="k">for</span> <span class="n">win</span><span class="p">,</span> <span class="n">loose</span> <span class="ow">in</span> <span class="n">adj_edges</span><span class="p">:</span>
</span><span id="by_edge_collapse-301"><a href="#by_edge_collapse-301"><span class="linenos">301</span></a>                <span class="k">if</span> <span class="n">fastremap</span><span class="p">:</span>
</span><span id="by_edge_collapse-302"><a href="#by_edge_collapse-302"><span class="linenos">302</span></a>                    <span class="n">face_edges</span> <span class="o">=</span> <span class="n">fastremap</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="n">face_edges</span><span class="p">,</span> <span class="p">{</span><span class="n">loose</span><span class="p">:</span> <span class="n">win</span><span class="p">},</span>
</span><span id="by_edge_collapse-303"><a href="#by_edge_collapse-303"><span class="linenos">303</span></a>                                                 <span class="n">preserve_missing_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
</span><span id="by_edge_collapse-304"><a href="#by_edge_collapse-304"><span class="linenos">304</span></a>                                                 <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="by_edge_collapse-305"><a href="#by_edge_collapse-305"><span class="linenos">305</span></a>                <span class="k">else</span><span class="p">:</span>
</span><span id="by_edge_collapse-306"><a href="#by_edge_collapse-306"><span class="linenos">306</span></a>                    <span class="n">face_edges</span><span class="p">[</span><span class="n">face_edges</span> <span class="o">==</span> <span class="n">loose</span><span class="p">]</span> <span class="o">=</span> <span class="n">win</span>
</span><span id="by_edge_collapse-307"><a href="#by_edge_collapse-307"><span class="linenos">307</span></a>                <span class="n">is_collapsed</span><span class="p">[</span><span class="n">loose</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="by_edge_collapse-308"><a href="#by_edge_collapse-308"><span class="linenos">308</span></a>
</span><span id="by_edge_collapse-309"><a href="#by_edge_collapse-309"><span class="linenos">309</span></a>            <span class="c1"># Replace occurrences of first node u with second node v</span>
</span><span id="by_edge_collapse-310"><a href="#by_edge_collapse-310"><span class="linenos">310</span></a>            <span class="k">if</span> <span class="n">fastremap</span><span class="p">:</span>
</span><span id="by_edge_collapse-311"><a href="#by_edge_collapse-311"><span class="linenos">311</span></a>                <span class="n">edges</span> <span class="o">=</span> <span class="n">fastremap</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="p">{</span><span class="n">u</span><span class="p">:</span> <span class="n">v</span><span class="p">},</span>
</span><span id="by_edge_collapse-312"><a href="#by_edge_collapse-312"><span class="linenos">312</span></a>                                        <span class="n">preserve_missing_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
</span><span id="by_edge_collapse-313"><a href="#by_edge_collapse-313"><span class="linenos">313</span></a>                                        <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="by_edge_collapse-314"><a href="#by_edge_collapse-314"><span class="linenos">314</span></a>            <span class="k">else</span><span class="p">:</span>
</span><span id="by_edge_collapse-315"><a href="#by_edge_collapse-315"><span class="linenos">315</span></a>                <span class="n">edges</span><span class="p">[</span><span class="n">edges</span> <span class="o">==</span> <span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
</span><span id="by_edge_collapse-316"><a href="#by_edge_collapse-316"><span class="linenos">316</span></a>
</span><span id="by_edge_collapse-317"><a href="#by_edge_collapse-317"><span class="linenos">317</span></a>            <span class="c1"># Add shape cost of u to shape costs of v</span>
</span><span id="by_edge_collapse-318"><a href="#by_edge_collapse-318"><span class="linenos">318</span></a>            <span class="n">Q_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Q_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">u</span><span class="p">]</span>
</span><span id="by_edge_collapse-319"><a href="#by_edge_collapse-319"><span class="linenos">319</span></a>
</span><span id="by_edge_collapse-320"><a href="#by_edge_collapse-320"><span class="linenos">320</span></a>            <span class="c1"># Determine which edges require update of costs:</span>
</span><span id="by_edge_collapse-321"><a href="#by_edge_collapse-321"><span class="linenos">321</span></a>            <span class="c1"># In theory we only need to update costs for edges that are</span>
</span><span id="by_edge_collapse-322"><a href="#by_edge_collapse-322"><span class="linenos">322</span></a>            <span class="c1"># associated with vertices v and u (which now also v)</span>
</span><span id="by_edge_collapse-323"><a href="#by_edge_collapse-323"><span class="linenos">323</span></a>            <span class="n">has_v</span> <span class="o">=</span> <span class="p">(</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span>
</span><span id="by_edge_collapse-324"><a href="#by_edge_collapse-324"><span class="linenos">324</span></a>
</span><span id="by_edge_collapse-325"><a href="#by_edge_collapse-325"><span class="linenos">325</span></a>            <span class="c1"># Uncomment to temporarily force updating costs for all edges</span>
</span><span id="by_edge_collapse-326"><a href="#by_edge_collapse-326"><span class="linenos">326</span></a>            <span class="c1"># has_v[:] = True</span>
</span><span id="by_edge_collapse-327"><a href="#by_edge_collapse-327"><span class="linenos">327</span></a>
</span><span id="by_edge_collapse-328"><a href="#by_edge_collapse-328"><span class="linenos">328</span></a>            <span class="c1"># Update shape costs</span>
</span><span id="by_edge_collapse-329"><a href="#by_edge_collapse-329"><span class="linenos">329</span></a>            <span class="n">this_Q1</span> <span class="o">=</span> <span class="n">Q_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">edges</span><span class="p">[</span><span class="n">has_v</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
</span><span id="by_edge_collapse-330"><a href="#by_edge_collapse-330"><span class="linenos">330</span></a>            <span class="n">this_Q2</span> <span class="o">=</span> <span class="n">Q_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">edges</span><span class="p">[</span><span class="n">has_v</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
</span><span id="by_edge_collapse-331"><a href="#by_edge_collapse-331"><span class="linenos">331</span></a>
</span><span id="by_edge_collapse-332"><a href="#by_edge_collapse-332"><span class="linenos">332</span></a>            <span class="n">F1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,kji-&gt;ij&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">has_v</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">this_Q1</span><span class="p">)[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
</span><span id="by_edge_collapse-333"><a href="#by_edge_collapse-333"><span class="linenos">333</span></a>            <span class="n">F2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,kji-&gt;ij&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">has_v</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">this_Q2</span><span class="p">)[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
</span><span id="by_edge_collapse-334"><a href="#by_edge_collapse-334"><span class="linenos">334</span></a>
</span><span id="by_edge_collapse-335"><a href="#by_edge_collapse-335"><span class="linenos">335</span></a>            <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span><span id="by_edge_collapse-336"><a href="#by_edge_collapse-336"><span class="linenos">336</span></a>            <span class="n">new_shape_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span><span id="by_edge_collapse-337"><a href="#by_edge_collapse-337"><span class="linenos">337</span></a>
</span><span id="by_edge_collapse-338"><a href="#by_edge_collapse-338"><span class="linenos">338</span></a>            <span class="c1"># Update sum of incoming edge lengths</span>
</span><span id="by_edge_collapse-339"><a href="#by_edge_collapse-339"><span class="linenos">339</span></a>            <span class="c1"># Technically we would have to recalculate lengths of adjacent edges</span>
</span><span id="by_edge_collapse-340"><a href="#by_edge_collapse-340"><span class="linenos">340</span></a>            <span class="c1"># every time but we will take the cheap way out and simply add them up</span>
</span><span id="by_edge_collapse-341"><a href="#by_edge_collapse-341"><span class="linenos">341</span></a>            <span class="n">verts_lengths</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">verts_lengths</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
</span><span id="by_edge_collapse-342"><a href="#by_edge_collapse-342"><span class="linenos">342</span></a>            <span class="c1"># Update sample costs for edges associated with v</span>
</span><span id="by_edge_collapse-343"><a href="#by_edge_collapse-343"><span class="linenos">343</span></a>            <span class="n">ik_edge</span> <span class="o">=</span> <span class="n">verts_lengths</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">has_v</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
</span><span id="by_edge_collapse-344"><a href="#by_edge_collapse-344"><span class="linenos">344</span></a>            <span class="n">new_sample_cost</span> <span class="o">=</span> <span class="n">edge_lengths</span><span class="p">[</span><span class="n">has_v</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ik_edge</span> <span class="o">-</span> <span class="n">edge_lengths</span><span class="p">[</span><span class="n">has_v</span><span class="p">])</span>
</span><span id="by_edge_collapse-345"><a href="#by_edge_collapse-345"><span class="linenos">345</span></a>
</span><span id="by_edge_collapse-346"><a href="#by_edge_collapse-346"><span class="linenos">346</span></a>            <span class="n">F_T</span><span class="p">[</span><span class="n">has_v</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_shape_cost</span> <span class="o">*</span> <span class="n">shape_weight</span> <span class="o">+</span> <span class="n">new_sample_cost</span> <span class="o">*</span> <span class="n">sample_weight</span>
</span><span id="by_edge_collapse-347"><a href="#by_edge_collapse-347"><span class="linenos">347</span></a>
</span><span id="by_edge_collapse-348"><a href="#by_edge_collapse-348"><span class="linenos">348</span></a>    <span class="c1"># After the edge collapse, the edges are garbled - I have yet to figure out</span>
</span><span id="by_edge_collapse-349"><a href="#by_edge_collapse-349"><span class="linenos">349</span></a>    <span class="c1"># why and whether that can be prevented. However the vertices in those</span>
</span><span id="by_edge_collapse-350"><a href="#by_edge_collapse-350"><span class="linenos">350</span></a>    <span class="c1"># edges are correct and so we just need to reconstruct their connectivity</span>
</span><span id="by_edge_collapse-351"><a href="#by_edge_collapse-351"><span class="linenos">351</span></a>    <span class="c1"># by extracting a minimum spanning tree over the mesh.</span>
</span><span id="by_edge_collapse-352"><a href="#by_edge_collapse-352"><span class="linenos">352</span></a>    <span class="n">corrected_edges</span> <span class="o">=</span> <span class="n">mst_over_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
</span><span id="by_edge_collapse-353"><a href="#by_edge_collapse-353"><span class="linenos">353</span></a>
</span><span id="by_edge_collapse-354"><a href="#by_edge_collapse-354"><span class="linenos">354</span></a>    <span class="c1"># Generate graph</span>
</span><span id="by_edge_collapse-355"><a href="#by_edge_collapse-355"><span class="linenos">355</span></a>    <span class="n">G</span> <span class="o">=</span> <span class="n">edges_to_graph</span><span class="p">(</span><span class="n">corrected_edges</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">fix_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
</span><span id="by_edge_collapse-356"><a href="#by_edge_collapse-356"><span class="linenos">356</span></a>                       <span class="n">weight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">drop_disconnected</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="by_edge_collapse-357"><a href="#by_edge_collapse-357"><span class="linenos">357</span></a>
</span><span id="by_edge_collapse-358"><a href="#by_edge_collapse-358"><span class="linenos">358</span></a>    <span class="n">swc</span><span class="p">,</span> <span class="n">new_ids</span> <span class="o">=</span> <span class="n">make_swc</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">reindex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="by_edge_collapse-359"><a href="#by_edge_collapse-359"><span class="linenos">359</span></a>
</span><span id="by_edge_collapse-360"><a href="#by_edge_collapse-360"><span class="linenos">360</span></a>    <span class="k">return</span> <span class="n">Skeleton</span><span class="p">(</span><span class="n">swc</span><span class="o">=</span><span class="n">swc</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;edge_collapse&#39;</span><span class="p">)</span>
</span></pre></div>


            <div class="docstring"><p>Skeletonize a (contracted) mesh by iteratively collapsing edges.</p>

<p>This algorithm (described in [1]) iteratively collapses edges that are part
of a face until no more faces are left. Edges are chosen based on a cost
function that penalizes collapses that would change the shape of the object
or would introduce long edges.</p>

<p>This is somewhat sensitive to the dimensions of the input mesh: too large
and you might experience slow-downs or numpy OverflowErrors; too low and
you might get skeletons that don't quite match the mesh (e.g. too few nodes).
If you experience either, try down- or up-scaling your mesh, respectively.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>mesh</strong> (mesh obj):
The mesh to be skeletonize. Can an object that has
<code>.vertices</code> and <code>.faces</code> properties  (e.g. a
trimesh.Trimesh) or a tuple <code>(vertices, faces)</code> or a
dictionary <code>{'vertices': vertices, 'faces': faces}</code>.</li>
<li><strong>shape_weight</strong> (float, optional):
Weight for shape costs which penalize collapsing edges that
would drastically change the shape of the object.</li>
<li><strong>sample_weight</strong> (float, optional):
Weight for sampling costs which penalize collapses that
would generate prohibitively long edges.</li>
<li><strong>progress</strong> (bool):
If True, will show progress bar.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong><a href="../skeletor.html#Skeleton">skeletor.Skeleton</a></strong>: Holds results of the skeletonization and enables quick
visualization.</li>
</ul>

<h6 id="references">References</h6>

<p>[1] Au OK, Tai CL, Chu HK, Cohen-Or D, Lee TY. Skeleton extraction by mesh
    contraction. ACM Transactions on Graphics (TOG). 2008 Aug 1;27(3):44.</p>
</div>


                </section>
                <section id="by_tangent_ball">
                            <input id="by_tangent_ball-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">by_tangent_ball</span><span class="signature pdoc-code condensed">(<span class="param"><span class="n">mesh</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="by_tangent_ball-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#by_tangent_ball"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="by_tangent_ball-125"><a href="#by_tangent_ball-125"><span class="linenos">125</span></a><span class="k">def</span> <span class="nf">by_tangent_ball</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
</span><span id="by_tangent_ball-126"><a href="#by_tangent_ball-126"><span class="linenos">126</span></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;Skeletonize a mesh by finding the maximal tangent ball.</span>
</span><span id="by_tangent_ball-127"><a href="#by_tangent_ball-127"><span class="linenos">127</span></a>
</span><span id="by_tangent_ball-128"><a href="#by_tangent_ball-128"><span class="linenos">128</span></a><span class="sd">    This algorithm casts a ray from every mesh vertex along its inverse normals</span>
</span><span id="by_tangent_ball-129"><a href="#by_tangent_ball-129"><span class="linenos">129</span></a><span class="sd">    (requires `ncollpyde`). It then creates a sphere that is tangent to the</span>
</span><span id="by_tangent_ball-130"><a href="#by_tangent_ball-130"><span class="linenos">130</span></a><span class="sd">    vertex and to where the ray hit the inside of a face on the opposite side.</span>
</span><span id="by_tangent_ball-131"><a href="#by_tangent_ball-131"><span class="linenos">131</span></a><span class="sd">    Next it drops spheres that overlap with another, larger sphere. Modified</span>
</span><span id="by_tangent_ball-132"><a href="#by_tangent_ball-132"><span class="linenos">132</span></a><span class="sd">    from [1].</span>
</span><span id="by_tangent_ball-133"><a href="#by_tangent_ball-133"><span class="linenos">133</span></a>
</span><span id="by_tangent_ball-134"><a href="#by_tangent_ball-134"><span class="linenos">134</span></a><span class="sd">    The method works best on smooth meshes and is rather sensitive to errors in</span>
</span><span id="by_tangent_ball-135"><a href="#by_tangent_ball-135"><span class="linenos">135</span></a><span class="sd">    the mesh such as incorrect normals (see `skeletor.pre.fix_mesh`), internal</span>
</span><span id="by_tangent_ball-136"><a href="#by_tangent_ball-136"><span class="linenos">136</span></a><span class="sd">    faces, noisy surface (try smoothing or downsampling) or holes in the mesh.</span>
</span><span id="by_tangent_ball-137"><a href="#by_tangent_ball-137"><span class="linenos">137</span></a>
</span><span id="by_tangent_ball-138"><a href="#by_tangent_ball-138"><span class="linenos">138</span></a><span class="sd">    Parameters</span>
</span><span id="by_tangent_ball-139"><a href="#by_tangent_ball-139"><span class="linenos">139</span></a><span class="sd">    ----------</span>
</span><span id="by_tangent_ball-140"><a href="#by_tangent_ball-140"><span class="linenos">140</span></a><span class="sd">    mesh :              mesh obj</span>
</span><span id="by_tangent_ball-141"><a href="#by_tangent_ball-141"><span class="linenos">141</span></a><span class="sd">                        The mesh to be skeletonize. Can an object that has</span>
</span><span id="by_tangent_ball-142"><a href="#by_tangent_ball-142"><span class="linenos">142</span></a><span class="sd">                        ``.vertices`` and ``.faces`` properties  (e.g. a</span>
</span><span id="by_tangent_ball-143"><a href="#by_tangent_ball-143"><span class="linenos">143</span></a><span class="sd">                        trimesh.Trimesh) or a tuple ``(vertices, faces)`` or a</span>
</span><span id="by_tangent_ball-144"><a href="#by_tangent_ball-144"><span class="linenos">144</span></a><span class="sd">                        dictionary ``{&#39;vertices&#39;: vertices, &#39;faces&#39;: faces}``.</span>
</span><span id="by_tangent_ball-145"><a href="#by_tangent_ball-145"><span class="linenos">145</span></a>
</span><span id="by_tangent_ball-146"><a href="#by_tangent_ball-146"><span class="linenos">146</span></a><span class="sd">    Returns</span>
</span><span id="by_tangent_ball-147"><a href="#by_tangent_ball-147"><span class="linenos">147</span></a><span class="sd">    -------</span>
</span><span id="by_tangent_ball-148"><a href="#by_tangent_ball-148"><span class="linenos">148</span></a><span class="sd">    skeletor.Skeleton</span>
</span><span id="by_tangent_ball-149"><a href="#by_tangent_ball-149"><span class="linenos">149</span></a><span class="sd">                        Holds results of the skeletonization and enables quick</span>
</span><span id="by_tangent_ball-150"><a href="#by_tangent_ball-150"><span class="linenos">150</span></a><span class="sd">                        visualization.</span>
</span><span id="by_tangent_ball-151"><a href="#by_tangent_ball-151"><span class="linenos">151</span></a>
</span><span id="by_tangent_ball-152"><a href="#by_tangent_ball-152"><span class="linenos">152</span></a><span class="sd">    Examples</span>
</span><span id="by_tangent_ball-153"><a href="#by_tangent_ball-153"><span class="linenos">153</span></a><span class="sd">    --------</span>
</span><span id="by_tangent_ball-154"><a href="#by_tangent_ball-154"><span class="linenos">154</span></a><span class="sd">    &gt;&gt;&gt; import skeletor as sk</span>
</span><span id="by_tangent_ball-155"><a href="#by_tangent_ball-155"><span class="linenos">155</span></a><span class="sd">    &gt;&gt;&gt; mesh = sk.example_mesh()</span>
</span><span id="by_tangent_ball-156"><a href="#by_tangent_ball-156"><span class="linenos">156</span></a><span class="sd">    &gt;&gt;&gt; fixed = sk.pre.fix_mesh(mesh, fix_normals=True, remove_disconnected=10)</span>
</span><span id="by_tangent_ball-157"><a href="#by_tangent_ball-157"><span class="linenos">157</span></a><span class="sd">    &gt;&gt;&gt; skel = sk.skeletonize.by_tangent_ball(fixed)</span>
</span><span id="by_tangent_ball-158"><a href="#by_tangent_ball-158"><span class="linenos">158</span></a>
</span><span id="by_tangent_ball-159"><a href="#by_tangent_ball-159"><span class="linenos">159</span></a><span class="sd">    References</span>
</span><span id="by_tangent_ball-160"><a href="#by_tangent_ball-160"><span class="linenos">160</span></a><span class="sd">    ----------</span>
</span><span id="by_tangent_ball-161"><a href="#by_tangent_ball-161"><span class="linenos">161</span></a><span class="sd">    [1] Ma, J., Bae, S.W. &amp; Choi, S. 3D medial axis point approximation using</span>
</span><span id="by_tangent_ball-162"><a href="#by_tangent_ball-162"><span class="linenos">162</span></a><span class="sd">        nearest neighbors and the normal field. Vis Comput 28, 7–19 (2012).</span>
</span><span id="by_tangent_ball-163"><a href="#by_tangent_ball-163"><span class="linenos">163</span></a><span class="sd">        https://doi.org/10.1007/s00371-011-0594-7</span>
</span><span id="by_tangent_ball-164"><a href="#by_tangent_ball-164"><span class="linenos">164</span></a>
</span><span id="by_tangent_ball-165"><a href="#by_tangent_ball-165"><span class="linenos">165</span></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="by_tangent_ball-166"><a href="#by_tangent_ball-166"><span class="linenos">166</span></a>    <span class="n">mesh</span> <span class="o">=</span> <span class="n">make_trimesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="by_tangent_ball-167"><a href="#by_tangent_ball-167"><span class="linenos">167</span></a>
</span><span id="by_tangent_ball-168"><a href="#by_tangent_ball-168"><span class="linenos">168</span></a>    <span class="c1"># Generate the KD tree</span>
</span><span id="by_tangent_ball-169"><a href="#by_tangent_ball-169"><span class="linenos">169</span></a>    <span class="n">tree</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
</span><span id="by_tangent_ball-170"><a href="#by_tangent_ball-170"><span class="linenos">170</span></a>
</span><span id="by_tangent_ball-171"><a href="#by_tangent_ball-171"><span class="linenos">171</span></a>    <span class="n">dist</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">]</span>
</span><span id="by_tangent_ball-172"><a href="#by_tangent_ball-172"><span class="linenos">172</span></a>
</span><span id="by_tangent_ball-173"><a href="#by_tangent_ball-173"><span class="linenos">173</span></a>    <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</span><span id="by_tangent_ball-174"><a href="#by_tangent_ball-174"><span class="linenos">174</span></a>    <span class="n">radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span><span id="by_tangent_ball-175"><a href="#by_tangent_ball-175"><span class="linenos">175</span></a>
</span><span id="by_tangent_ball-176"><a href="#by_tangent_ball-176"><span class="linenos">176</span></a>    <span class="n">coll</span> <span class="o">=</span> <span class="n">ncollpyde</span><span class="o">.</span><span class="n">Volume</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="by_tangent_ball-177"><a href="#by_tangent_ball-177"><span class="linenos">177</span></a>    <span class="n">sources</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">-</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertex_normals</span> <span class="o">*</span> <span class="mf">0.01</span>
</span><span id="by_tangent_ball-178"><a href="#by_tangent_ball-178"><span class="linenos">178</span></a>    <span class="n">targets</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">-</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertex_normals</span> <span class="o">*</span> <span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
</span><span id="by_tangent_ball-179"><a href="#by_tangent_ball-179"><span class="linenos">179</span></a>    <span class="n">ix</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">is_backface</span> <span class="o">=</span> <span class="n">coll</span><span class="o">.</span><span class="n">intersections</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">targets</span><span class="p">)</span>
</span><span id="by_tangent_ball-180"><a href="#by_tangent_ball-180"><span class="linenos">180</span></a>
</span><span id="by_tangent_ball-181"><a href="#by_tangent_ball-181"><span class="linenos">181</span></a>    <span class="c1"># Now we need to invalidate centers</span>
</span><span id="by_tangent_ball-182"><a href="#by_tangent_ball-182"><span class="linenos">182</span></a>    <span class="n">intersects</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
</span><span id="by_tangent_ball-183"><a href="#by_tangent_ball-183"><span class="linenos">183</span></a>    <span class="n">intersects</span><span class="p">[</span><span class="n">ix</span><span class="p">[</span><span class="n">is_backface</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="by_tangent_ball-184"><a href="#by_tangent_ball-184"><span class="linenos">184</span></a>    <span class="n">centers</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">loc</span> <span class="o">-</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
</span><span id="by_tangent_ball-185"><a href="#by_tangent_ball-185"><span class="linenos">185</span></a>    <span class="n">radii</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">loc</span> <span class="o">-</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</span><span id="by_tangent_ball-186"><a href="#by_tangent_ball-186"><span class="linenos">186</span></a>
</span><span id="by_tangent_ball-187"><a href="#by_tangent_ball-187"><span class="linenos">187</span></a>    <span class="c1"># Now we need to post processing</span>
</span><span id="by_tangent_ball-188"><a href="#by_tangent_ball-188"><span class="linenos">188</span></a>    <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
</span><span id="by_tangent_ball-189"><a href="#by_tangent_ball-189"><span class="linenos">189</span></a>
</span><span id="by_tangent_ball-190"><a href="#by_tangent_ball-190"><span class="linenos">190</span></a>    <span class="c1"># Invalidate vertices that didn&#39;t intersect</span>
</span><span id="by_tangent_ball-191"><a href="#by_tangent_ball-191"><span class="linenos">191</span></a>    <span class="n">inv</span><span class="p">[</span><span class="o">~</span><span class="n">intersects</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="by_tangent_ball-192"><a href="#by_tangent_ball-192"><span class="linenos">192</span></a>
</span><span id="by_tangent_ball-193"><a href="#by_tangent_ball-193"><span class="linenos">193</span></a>    <span class="c1"># Now invalidate any ball that is outside the mesh</span>
</span><span id="by_tangent_ball-194"><a href="#by_tangent_ball-194"><span class="linenos">194</span></a>    <span class="n">inv</span><span class="p">[</span><span class="o">~</span><span class="n">coll</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">centers</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="by_tangent_ball-195"><a href="#by_tangent_ball-195"><span class="linenos">195</span></a>
</span><span id="by_tangent_ball-196"><a href="#by_tangent_ball-196"><span class="linenos">196</span></a>    <span class="c1"># Find tangent balls that are fully contained in another tangent ball</span>
</span><span id="by_tangent_ball-197"><a href="#by_tangent_ball-197"><span class="linenos">197</span></a>    <span class="c1"># (those are not maximal inscribed)</span>
</span><span id="by_tangent_ball-198"><a href="#by_tangent_ball-198"><span class="linenos">198</span></a>    <span class="n">original_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span><span id="by_tangent_ball-199"><a href="#by_tangent_ball-199"><span class="linenos">199</span></a>    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span><span id="by_tangent_ball-200"><a href="#by_tangent_ball-200"><span class="linenos">200</span></a>        <span class="n">tree2</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">])</span>
</span><span id="by_tangent_ball-201"><a href="#by_tangent_ball-201"><span class="linenos">201</span></a>        <span class="c1"># For any not-yet-invalidated center find the closest other center</span>
</span><span id="by_tangent_ball-202"><a href="#by_tangent_ball-202"><span class="linenos">202</span></a>        <span class="n">dist</span><span class="p">,</span> <span class="n">ix</span> <span class="o">=</span> <span class="n">tree2</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</span><span id="by_tangent_ball-203"><a href="#by_tangent_ball-203"><span class="linenos">203</span></a>
</span><span id="by_tangent_ball-204"><a href="#by_tangent_ball-204"><span class="linenos">204</span></a>        <span class="c1"># Drop self-hits</span>
</span><span id="by_tangent_ball-205"><a href="#by_tangent_ball-205"><span class="linenos">205</span></a>        <span class="n">ix</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dist</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
</span><span id="by_tangent_ball-206"><a href="#by_tangent_ball-206"><span class="linenos">206</span></a>
</span><span id="by_tangent_ball-207"><a href="#by_tangent_ball-207"><span class="linenos">207</span></a>        <span class="c1"># In radius</span>
</span><span id="by_tangent_ball-208"><a href="#by_tangent_ball-208"><span class="linenos">208</span></a>        <span class="n">in_radius</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">radii</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">]</span>
</span><span id="by_tangent_ball-209"><a href="#by_tangent_ball-209"><span class="linenos">209</span></a>
</span><span id="by_tangent_ball-210"><a href="#by_tangent_ball-210"><span class="linenos">210</span></a>        <span class="c1"># Stop if no more overlapping pairs</span>
</span><span id="by_tangent_ball-211"><a href="#by_tangent_ball-211"><span class="linenos">211</span></a>        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_radius</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
</span><span id="by_tangent_ball-212"><a href="#by_tangent_ball-212"><span class="linenos">212</span></a>            <span class="k">break</span>
</span><span id="by_tangent_ball-213"><a href="#by_tangent_ball-213"><span class="linenos">213</span></a>
</span><span id="by_tangent_ball-214"><a href="#by_tangent_ball-214"><span class="linenos">214</span></a>        <span class="c1"># Collect radii to determine which of the overlapping ball survives</span>
</span><span id="by_tangent_ball-215"><a href="#by_tangent_ball-215"><span class="linenos">215</span></a>        <span class="n">pair_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">radii</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">][</span><span class="n">in_radius</span><span class="p">],</span>
</span><span id="by_tangent_ball-216"><a href="#by_tangent_ball-216"><span class="linenos">216</span></a>                              <span class="n">radii</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">][</span><span class="n">ix</span><span class="p">[</span><span class="n">in_radius</span><span class="p">]]))</span><span class="o">.</span><span class="n">T</span>
</span><span id="by_tangent_ball-217"><a href="#by_tangent_ball-217"><span class="linenos">217</span></a>        <span class="n">pair_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">original_ind</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">][</span><span class="n">in_radius</span><span class="p">],</span>
</span><span id="by_tangent_ball-218"><a href="#by_tangent_ball-218"><span class="linenos">218</span></a>                             <span class="n">original_ind</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">][</span><span class="n">ix</span><span class="p">[</span><span class="n">in_radius</span><span class="p">]]))</span><span class="o">.</span><span class="n">T</span>
</span><span id="by_tangent_ball-219"><a href="#by_tangent_ball-219"><span class="linenos">219</span></a>
</span><span id="by_tangent_ball-220"><a href="#by_tangent_ball-220"><span class="linenos">220</span></a>        <span class="c1"># Invalidate the loosers</span>
</span><span id="by_tangent_ball-221"><a href="#by_tangent_ball-221"><span class="linenos">221</span></a>        <span class="n">looses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">pair_rad</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span><span id="by_tangent_ball-222"><a href="#by_tangent_ball-222"><span class="linenos">222</span></a>        <span class="n">looser_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pair_ix</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pair_ix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">looses</span><span class="p">])</span>
</span><span id="by_tangent_ball-223"><a href="#by_tangent_ball-223"><span class="linenos">223</span></a>        <span class="n">inv</span><span class="p">[</span><span class="n">looser_ix</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="by_tangent_ball-224"><a href="#by_tangent_ball-224"><span class="linenos">224</span></a>
</span><span id="by_tangent_ball-225"><a href="#by_tangent_ball-225"><span class="linenos">225</span></a>    <span class="c1"># Now we need to collapse nodes into the remaining centers</span>
</span><span id="by_tangent_ball-226"><a href="#by_tangent_ball-226"><span class="linenos">226</span></a>    <span class="n">G</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
</span><span id="by_tangent_ball-227"><a href="#by_tangent_ball-227"><span class="linenos">227</span></a>                 <span class="n">edges</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">,</span>
</span><span id="by_tangent_ball-228"><a href="#by_tangent_ball-228"><span class="linenos">228</span></a>                 <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="by_tangent_ball-229"><a href="#by_tangent_ball-229"><span class="linenos">229</span></a>
</span><span id="by_tangent_ball-230"><a href="#by_tangent_ball-230"><span class="linenos">230</span></a>    <span class="c1"># Make sure that every connected component has at least one valid target</span>
</span><span id="by_tangent_ball-231"><a href="#by_tangent_ball-231"><span class="linenos">231</span></a>    <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">connected_components</span><span class="p">():</span>
</span><span id="by_tangent_ball-232"><a href="#by_tangent_ball-232"><span class="linenos">232</span></a>        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">original_ind</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
</span><span id="by_tangent_ball-233"><a href="#by_tangent_ball-233"><span class="linenos">233</span></a>            <span class="n">inv</span><span class="p">[</span><span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="by_tangent_ball-234"><a href="#by_tangent_ball-234"><span class="linenos">234</span></a>            <span class="n">centers</span><span class="p">[</span><span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
</span><span id="by_tangent_ball-235"><a href="#by_tangent_ball-235"><span class="linenos">235</span></a>
</span><span id="by_tangent_ball-236"><a href="#by_tangent_ball-236"><span class="linenos">236</span></a>    <span class="c1"># For each invalidated vertex, find the closest vertex that is still valid</span>
</span><span id="by_tangent_ball-237"><a href="#by_tangent_ball-237"><span class="linenos">237</span></a>    <span class="c1"># This works on unweighted edges but should be good enough - way faster</span>
</span><span id="by_tangent_ball-238"><a href="#by_tangent_ball-238"><span class="linenos">238</span></a>    <span class="c1"># than a proper path search for sure</span>
</span><span id="by_tangent_ball-239"><a href="#by_tangent_ball-239"><span class="linenos">239</span></a>    <span class="n">pairs</span> <span class="o">=</span> <span class="n">find_closest</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">sources</span><span class="o">=</span><span class="n">original_ind</span><span class="p">[</span><span class="n">inv</span><span class="p">],</span>
</span><span id="by_tangent_ball-240"><a href="#by_tangent_ball-240"><span class="linenos">240</span></a>                         <span class="n">targets</span><span class="o">=</span><span class="n">original_ind</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">])</span>
</span><span id="by_tangent_ball-241"><a href="#by_tangent_ball-241"><span class="linenos">241</span></a>
</span><span id="by_tangent_ball-242"><a href="#by_tangent_ball-242"><span class="linenos">242</span></a>    <span class="c1"># Generate a mesh vertex to skeleton node map</span>
</span><span id="by_tangent_ball-243"><a href="#by_tangent_ball-243"><span class="linenos">243</span></a>    <span class="n">mesh_map</span> <span class="o">=</span> <span class="n">original_ind</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</span><span id="by_tangent_ball-244"><a href="#by_tangent_ball-244"><span class="linenos">244</span></a>    <span class="n">mesh_map</span><span class="p">[</span><span class="n">pairs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
</span><span id="by_tangent_ball-245"><a href="#by_tangent_ball-245"><span class="linenos">245</span></a>
</span><span id="by_tangent_ball-246"><a href="#by_tangent_ball-246"><span class="linenos">246</span></a>    <span class="c1"># Renumber the vertices from 0 -&gt; N_vertices</span>
</span><span id="by_tangent_ball-247"><a href="#by_tangent_ball-247"><span class="linenos">247</span></a>    <span class="n">uni</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">mesh_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mesh_map</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="by_tangent_ball-248"><a href="#by_tangent_ball-248"><span class="linenos">248</span></a>
</span><span id="by_tangent_ball-249"><a href="#by_tangent_ball-249"><span class="linenos">249</span></a>    <span class="c1"># Make sure centers and radii match the new order</span>
</span><span id="by_tangent_ball-250"><a href="#by_tangent_ball-250"><span class="linenos">250</span></a>    <span class="n">centers</span> <span class="o">=</span> <span class="n">centers</span><span class="p">[</span><span class="n">uni</span><span class="p">]</span>
</span><span id="by_tangent_ball-251"><a href="#by_tangent_ball-251"><span class="linenos">251</span></a>    <span class="n">radii</span> <span class="o">=</span> <span class="n">radii</span><span class="p">[</span><span class="n">uni</span><span class="p">]</span>
</span><span id="by_tangent_ball-252"><a href="#by_tangent_ball-252"><span class="linenos">252</span></a>
</span><span id="by_tangent_ball-253"><a href="#by_tangent_ball-253"><span class="linenos">253</span></a>    <span class="c1"># Contract vertices to nodes according to the mesh</span>
</span><span id="by_tangent_ball-254"><a href="#by_tangent_ball-254"><span class="linenos">254</span></a>    <span class="n">G</span><span class="o">.</span><span class="n">contract_vertices</span><span class="p">(</span><span class="n">mesh_map</span><span class="p">,</span> <span class="n">combine_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</span><span id="by_tangent_ball-255"><a href="#by_tangent_ball-255"><span class="linenos">255</span></a>
</span><span id="by_tangent_ball-256"><a href="#by_tangent_ball-256"><span class="linenos">256</span></a>    <span class="c1"># This only drops duplicate and self-loop edges</span>
</span><span id="by_tangent_ball-257"><a href="#by_tangent_ball-257"><span class="linenos">257</span></a>    <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
</span><span id="by_tangent_ball-258"><a href="#by_tangent_ball-258"><span class="linenos">258</span></a>
</span><span id="by_tangent_ball-259"><a href="#by_tangent_ball-259"><span class="linenos">259</span></a>    <span class="c1"># Generate weights between remaining centers</span>
</span><span id="by_tangent_ball-260"><a href="#by_tangent_ball-260"><span class="linenos">260</span></a>    <span class="n">el</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">get_edgelist</span><span class="p">())</span>
</span><span id="by_tangent_ball-261"><a href="#by_tangent_ball-261"><span class="linenos">261</span></a>    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="n">el</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">centers</span><span class="p">[</span><span class="n">el</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span><span id="by_tangent_ball-262"><a href="#by_tangent_ball-262"><span class="linenos">262</span></a>
</span><span id="by_tangent_ball-263"><a href="#by_tangent_ball-263"><span class="linenos">263</span></a>    <span class="c1"># Generate hierarchical tree</span>
</span><span id="by_tangent_ball-264"><a href="#by_tangent_ball-264"><span class="linenos">264</span></a>    <span class="n">tree</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spanning_tree</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
</span><span id="by_tangent_ball-265"><a href="#by_tangent_ball-265"><span class="linenos">265</span></a>
</span><span id="by_tangent_ball-266"><a href="#by_tangent_ball-266"><span class="linenos">266</span></a>    <span class="c1"># Create a directed acyclic and hierarchical graph</span>
</span><span id="by_tangent_ball-267"><a href="#by_tangent_ball-267"><span class="linenos">267</span></a>    <span class="n">G_nx</span> <span class="o">=</span> <span class="n">edges_to_graph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">get_edgelist</span><span class="p">()),</span>
</span><span id="by_tangent_ball-268"><a href="#by_tangent_ball-268"><span class="linenos">268</span></a>                          <span class="n">nodes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vs</span><span class="p">)),</span>
</span><span id="by_tangent_ball-269"><a href="#by_tangent_ball-269"><span class="linenos">269</span></a>                          <span class="n">fix_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
</span><span id="by_tangent_ball-270"><a href="#by_tangent_ball-270"><span class="linenos">270</span></a>                          <span class="n">drop_disconnected</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="by_tangent_ball-271"><a href="#by_tangent_ball-271"><span class="linenos">271</span></a>
</span><span id="by_tangent_ball-272"><a href="#by_tangent_ball-272"><span class="linenos">272</span></a>    <span class="c1"># Generate the SWC table</span>
</span><span id="by_tangent_ball-273"><a href="#by_tangent_ball-273"><span class="linenos">273</span></a>    <span class="n">swc</span> <span class="o">=</span> <span class="n">make_swc</span><span class="p">(</span><span class="n">G_nx</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">centers</span><span class="p">,</span> <span class="n">reindex</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="by_tangent_ball-274"><a href="#by_tangent_ball-274"><span class="linenos">274</span></a>    <span class="n">swc</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">radii</span><span class="p">[</span><span class="n">swc</span><span class="o">.</span><span class="n">node_id</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>
</span><span id="by_tangent_ball-275"><a href="#by_tangent_ball-275"><span class="linenos">275</span></a>    <span class="n">_</span><span class="p">,</span> <span class="n">new_ids</span> <span class="o">=</span> <span class="n">reindex_swc</span><span class="p">(</span><span class="n">swc</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="by_tangent_ball-276"><a href="#by_tangent_ball-276"><span class="linenos">276</span></a>
</span><span id="by_tangent_ball-277"><a href="#by_tangent_ball-277"><span class="linenos">277</span></a>    <span class="c1"># Update vertex to node ID map</span>
</span><span id="by_tangent_ball-278"><a href="#by_tangent_ball-278"><span class="linenos">278</span></a>    <span class="n">mesh_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_ids</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mesh_map</span><span class="p">])</span>
</span><span id="by_tangent_ball-279"><a href="#by_tangent_ball-279"><span class="linenos">279</span></a>
</span><span id="by_tangent_ball-280"><a href="#by_tangent_ball-280"><span class="linenos">280</span></a>    <span class="k">return</span> <span class="n">Skeleton</span><span class="p">(</span><span class="n">swc</span><span class="o">=</span><span class="n">swc</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh_map</span><span class="o">=</span><span class="n">mesh_map</span><span class="p">,</span>
</span><span id="by_tangent_ball-281"><a href="#by_tangent_ball-281"><span class="linenos">281</span></a>                    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;tangent_ball&#39;</span><span class="p">)</span>
</span></pre></div>


            <div class="docstring"><p>Skeletonize a mesh by finding the maximal tangent ball.</p>

<p>This algorithm casts a ray from every mesh vertex along its inverse normals
(requires <code>ncollpyde</code>). It then creates a sphere that is tangent to the
vertex and to where the ray hit the inside of a face on the opposite side.
Next it drops spheres that overlap with another, larger sphere. Modified
from [1].</p>

<p>The method works best on smooth meshes and is rather sensitive to errors in
the mesh such as incorrect normals (see <code><a href="pre.html#fix_mesh">skeletor.pre.fix_mesh</a></code>), internal
faces, noisy surface (try smoothing or downsampling) or holes in the mesh.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>mesh</strong> (mesh obj):
The mesh to be skeletonize. Can an object that has
<code>.vertices</code> and <code>.faces</code> properties  (e.g. a
trimesh.Trimesh) or a tuple <code>(vertices, faces)</code> or a
dictionary <code>{'vertices': vertices, 'faces': faces}</code>.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong><a href="../skeletor.html#Skeleton">skeletor.Skeleton</a></strong>: Holds results of the skeletonization and enables quick
visualization.</li>
</ul>

<h6 id="examples">Examples</h6>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">skeletor</span> <span class="k">as</span> <span class="nn">sk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">example_mesh</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fixed</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">pre</span><span class="o">.</span><span class="n">fix_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">fix_normals</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">remove_disconnected</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeletonize</span><span class="o">.</span><span class="n">by_tangent_ball</span><span class="p">(</span><span class="n">fixed</span><span class="p">)</span>
</code></pre>
</div>

<h6 id="references">References</h6>

<p>[1] Ma, J., Bae, S.W. &amp; Choi, S. 3D medial axis point approximation using
    nearest neighbors and the normal field. Vis Comput 28, 7–19 (2012).
    <a href="https://doi.org/10.1007/s00371-011-0594-7">https://doi.org/10.1007/s00371-011-0594-7</a></p>
</div>


                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.kind) {
                    case "function":
                        if (doc.fullname.endsWith(".__init__")) {
                            heading = `<span class="name">${doc.fullname.replace(/\.__init__$/, "")}</span>${doc.signature}`;
                        } else {
                            heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span>${doc.signature}`;
                        }
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        if (doc.bases)
                            heading += `<wbr>(<span class="base">${doc.bases}</span>)`;
                        heading += `:`;
                        break;
                    case "variable":
                        heading = `<span class="name">${doc.fullname}</span>`;
                        if (doc.annotation)
                            heading += `<span class="annotation">${doc.annotation}</span>`;
                        if (doc.default_value)
                            heading += `<span class="default_value"> = ${doc.default_value}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.kind}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>